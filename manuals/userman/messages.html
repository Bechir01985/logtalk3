

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Messages &mdash; The Logtalk Handbook v3.21.0-b01 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/logtalk.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Objects" href="objects.html" />
    <link rel="prev" title="Nomenclature" href="nomenclature.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Logtalk Handbook
          

          
          </a>

          
            
            
              <div class="version">
                3.21.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="features.html">Main features</a></li>
<li class="toctree-l2"><a class="reference internal" href="nomenclature.html">Nomenclature</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Messages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operators-used-in-message-sending">Operators used in message sending</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sending-a-message-to-an-object">Sending a message to an object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delegating-a-message-to-an-object">Delegating a message to an object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sending-a-message-to-self">Sending a message to <em>self</em></a></li>
<li class="toctree-l3"><a class="reference internal" href="#broadcasting">Broadcasting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calling-imported-and-inherited-predicates">Calling imported and inherited predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#message-sending-and-event-generation">Message sending and event generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#message-sending-performance">Message sending performance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#translating-message-processing-to-predicate-calls">Translating message processing to predicate calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#processing-time">Processing time</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="categories.html">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">Predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="inheritance.html">Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="events.html">Event-driven programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="threads.html">Multi-threading programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="errors.html">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="documenting.html">Documenting applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="installing.html">Installing Logtalk</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming.html">Writing, running, and debugging applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="migration.html">Prolog Integration and Migration Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
</ul>

            
          
    <a href="genindex.html">Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Logtalk Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">User Manual</a> &raquo;</li>
        
      <li>Messages</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/userman/messages.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="messages">
<span id="messages-messages"></span><h1>Messages<a class="headerlink" href="#messages" title="Permalink to this headline">¶</a></h1>
<p>Messages allows us to call object predicates. Logtalk uses the same
nomenclature found in other object-oriented programming languages such
as Smalltalk. Therefore, the terms <em>predicate</em> and <em>method</em> are often
used interchangeably when referring to predicates defined inside objects
and categories. A message must always match a predicate within the scope
of the sender object.</p>
<p>Note that message sending is only the same as calling an object’s
predicate if the object does not inherit (or import) predicate
definitions from other objects (or categories). Otherwise, the predicate
definition that will be executed may depend on the relationships of the
object with other Logtalk entities.</p>
<div class="section" id="operators-used-in-message-sending">
<span id="messages-operators"></span><h2>Operators used in message sending<a class="headerlink" href="#operators-used-in-message-sending" title="Permalink to this headline">¶</a></h2>
<p>Logtalk declares the following operators for the message sending control
constructs:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">op</span>(<span class="m">600</span>, xfy, <span class="o">::</span>).
<span class="p">:- </span><span class="k">op</span>(<span class="m">600</span>,  fy, <span class="o">::</span>).
<span class="p">:- </span><span class="k">op</span>(<span class="m">600</span>,  fy, <span class="o">^^</span>).
</pre></div>
</div>
<p>It is assumed that these operators remain active (once the Logtalk
compiler and runtime files are loaded) until the end of the Prolog
session (this is the usual behavior of most Prolog compilers). Note that
these operator definitions are compatible with the predefined operators
in the Prolog ISO standard.</p>
</div>
<div class="section" id="sending-a-message-to-an-object">
<span id="messages-sending"></span><h2>Sending a message to an object<a class="headerlink" href="#sending-a-message-to-an-object" title="Permalink to this headline">¶</a></h2>
<p>Sending a message to an object is accomplished by using the
<a class="reference internal" href="../refman/control/send_to_object_2.html#control-send-to-object-2"><span class="std std-ref">::/2</span></a> control construct:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- Object::Message.
</pre></div>
</div>
<p>The message must match a public predicate declared for the receiving
object. The message may also correspond to a protected or private
predicate if the <em>sender</em> matches the predicate scope container. If the
predicate is declared but not defined, the message simply fails (as per
the <a class="reference internal" href="../glossary.html#term-closed-world-assumption"><span class="xref std std-term">closed-world assumption</span></a>).</p>
</div>
<div class="section" id="delegating-a-message-to-an-object">
<span id="messages-delegating"></span><h2>Delegating a message to an object<a class="headerlink" href="#delegating-a-message-to-an-object" title="Permalink to this headline">¶</a></h2>
<p>It is also possible to send a message to an object while preserving the
original <em>sender</em> by using the <a class="reference internal" href="../refman/control/delegate_message_1.html#control-delegate-message-1"><span class="std std-ref">[]/1</span></a> delegation
control construct:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>..., [<span class="nv">Object</span><span class="o">::</span><span class="nv">Message</span>], ....
</pre></div>
</div>
<p>This control construct can only be used within objects and categories
(at the interpreter top-level, the <em>sender</em> is always the pseudo-object
<em>user</em> so using this control construct would be equivalent to use the
<code class="docutils literal notranslate"><span class="pre">::/2</span></code> message sending control construct).</p>
</div>
<div class="section" id="sending-a-message-to-self">
<h2>Sending a message to <em>self</em><a class="headerlink" href="#sending-a-message-to-self" title="Permalink to this headline">¶</a></h2>
<p>While defining a predicate, we sometimes need to send a message to
<em>self</em>, i.e., to the same object that has received the original message.
This is done in Logtalk through the
<a class="reference internal" href="../refman/control/send_to_self_1.html#control-send-to-self-1"><span class="std std-ref">::/1</span></a> control construct:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="o">::</span><span class="nv">Message</span>
</pre></div>
</div>
<p>The message must match either a public or protected predicate declared
for the receiving object or a private predicate within the scope of the
<em>sender</em> otherwise an error will be thrown (see the Reference Manual for
details). If the message is sent from inside a category or if we are
using private inheritance, then the message may also match a private
predicate. Again, if the predicate is declared but not defined, the
message simply fails (as per the <a class="reference internal" href="../glossary.html#term-closed-world-assumption"><span class="xref std std-term">closed-world assumption</span></a>).</p>
</div>
<div class="section" id="broadcasting">
<span id="messages-broadcasting"></span><h2>Broadcasting<a class="headerlink" href="#broadcasting" title="Permalink to this headline">¶</a></h2>
<p>In the Logtalk context, broadcasting is interpreted as the sending of
several messages to the same object. This can be achieved by using the
message sending method described above. However, for convenience,
Logtalk implements an extended syntax for message sending that may
improve program readability in some cases. This extended syntax uses the
<code class="docutils literal notranslate"><span class="pre">(,)/2</span></code>, <code class="docutils literal notranslate"><span class="pre">(;)/2</span></code>, and <code class="docutils literal notranslate"><span class="pre">(-&gt;)/2</span></code> control constructs. For example, if
we wish to send several messages to the same object, we can write:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- Object::(Message1, Message2, ...).
</pre></div>
</div>
<p>This is semantically equivalent to:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- Object::Message1, Object::Message2, ... .
</pre></div>
</div>
<p>This extended syntax may also be used with the <code class="docutils literal notranslate"><span class="pre">::/1</span></code> message sending
control construct.</p>
</div>
<div class="section" id="calling-imported-and-inherited-predicates">
<span id="messages-super"></span><h2>Calling imported and inherited predicates<a class="headerlink" href="#calling-imported-and-inherited-predicates" title="Permalink to this headline">¶</a></h2>
<p>When redefining a predicate, sometimes we need to call the inherited
definition in the new code. This functionality, introduced by the
Smalltalk language through the <code class="docutils literal notranslate"><span class="pre">super</span></code> primitive, is available in
Logtalk using the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a> control construct:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="o">^^</span><span class="nv">Predicate</span>
</pre></div>
</div>
<p>Most of the time we will use this control construct by instantiating the
pattern:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="nv">Predicate</span> <span class="o">:-</span>
    ...,            <span class="c">% do something</span>
    <span class="o">^^</span><span class="nv">Predicate</span>,    <span class="c">% call inherited definition</span>
    ... .           <span class="c">% do something more</span>
</pre></div>
</div>
<p>This control construct is generalized in Logtalk where it may be used to
call any imported or inherited predicate definition. This control
construct may be used within objects and categories. When combined with
<a class="reference internal" href="../glossary.html#term-static-binding"><span class="xref std std-term">static binding</span></a>, this control construct allows imported and inherited
predicates to be called with the same performance of local predicates.
As with the message sending control constructs, the <code class="docutils literal notranslate"><span class="pre">^^/1</span></code> call simply
fails when the predicate is declared but not defined (as per the
<a class="reference internal" href="../glossary.html#term-closed-world-assumption"><span class="xref std std-term">closed-world assumption</span></a>).</p>
</div>
<div class="section" id="message-sending-and-event-generation">
<span id="messages-events"></span><h2>Message sending and event generation<a class="headerlink" href="#message-sending-and-event-generation" title="Permalink to this headline">¶</a></h2>
<p>Every message sent using the
<a class="reference internal" href="../refman/control/send_to_object_2.html#control-send-to-object-2"><span class="std std-ref">::/2</span></a> control construct
generates two events, one before and one after the message execution.
Messages that are sent using the
<a class="reference internal" href="../refman/control/send_to_self_1.html#control-send-to-self-1"><span class="std std-ref">::/1</span></a> (message to <em>self</em>)
control construct or the
<a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a> super mechanism
described above do not generate any events. The rationale behind this
distinction is that messages to <em>self</em> and <em>super</em> calls are only used
internally in the definition of methods or to execute additional
messages with the same target object (represented by <em>self</em>). In other
words, events are only generated when using an object’s public
interface; they cannot be used to break object encapsulation.</p>
<p>If we need to generate events for a public message sent to <em>self</em>, then
we just need to write something like:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="nv">Predicate</span> <span class="o">:-</span>
    ...,
    <span class="c">% get self reference</span>
    <span class="k">self</span>(<span class="nv">Self</span>),
    <span class="c">% send a message to self using ::/2</span>
    <span class="nv">Self</span><span class="o">::</span><span class="nv">Message</span>,
    ... .
</pre></div>
</div>
<p>If we also need the sender of the message to be other than the object
containing the predicate definition, we can write:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="nv">Predicate</span> <span class="o">:-</span>
    ...,
    <span class="c">% send a message to self using ::/2</span>
    <span class="c">% sender will be the pseudo-object user</span>
    <span class="k">self</span>(<span class="nv">Self</span>),
    <span class="k">{</span><span class="nv">Self</span><span class="o">::</span><span class="nv">Message</span><span class="k">}</span>,
    ... .
</pre></div>
</div>
<p>When events are not used, is possible to turn off event generation on a
per object basis by using the <a class="reference internal" href="programming.html#flag-events"><span class="std std-ref">events</span></a> compiler
flag (see the <a class="reference internal" href="events.html#events-events"><span class="std std-ref">Event-driven programming</span></a> section for more details).</p>
</div>
<div class="section" id="message-sending-performance">
<span id="messages-performance"></span><h2>Message sending performance<a class="headerlink" href="#message-sending-performance" title="Permalink to this headline">¶</a></h2>
<p>Logtalk supports both <a class="reference internal" href="../glossary.html#term-static-binding"><span class="xref std std-term">static binding</span></a> and <a class="reference internal" href="../glossary.html#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a>.
Static binding is used whenever messages are sent (using the <code class="docutils literal notranslate"><span class="pre">::/2</span></code> control
construct) to static objects already loaded and with the
<a class="reference internal" href="programming.html#flag-optimize"><span class="std std-ref">optimize</span></a> compiler flag turned on. When that is not
the case (or when using the <code class="docutils literal notranslate"><span class="pre">::/1</span></code> control construct), Logtalk uses dynamic
binding coupled with a caching mechanism that avoids repeated lookups of
predicate declarations and predicate definitions. This is a solution common
to other programming languages supporting dynamic binding. Message lookups are
automatically cached the first time a message is sent. Cache entries are
automatically removed when loading entities or using Logtalk dynamic
features that invalidate the cached lookups.</p>
<p>Whenever static binding is used, message sending performance is roughly
the same as a predicate call in plain Prolog. When discussing Logtalk
dynamic binding performance, two distinct cases should be considered:
messages sent by the user from the top-level interpreter and messages
sent from compiled objects. In addition, the message declaration and
definition lookups may, or may not be already cached by the runtime
engine. In what follows, we will assume that the message lookups are
already cached.</p>
<div class="section" id="translating-message-processing-to-predicate-calls">
<span id="messages-inferences"></span><h3>Translating message processing to predicate calls<a class="headerlink" href="#translating-message-processing-to-predicate-calls" title="Permalink to this headline">¶</a></h3>
<p>In order to better understand the performance trade-offs of using Logtalk
dynamic binding when compared to plain Prolog or to Prolog module
systems, is useful to translate message processing in terms of predicate
calls. However, in doing this, we should keep in mind that the number of
predicate calls is not necessarily proportional to the time taken to
execute them.</p>
<p>With event-support turned on, a message sent from a compiled object (or
category) to another object translates to a minimum of five predicate
calls:</p>
<dl class="docutils">
<dt>checking for <em>before</em> events</dt>
<dd>one call to the built-in predicate <code class="docutils literal notranslate"><span class="pre">\+/1</span></code> and a call to its
argument, assuming that no events are defined</dd>
<dt>method call using the cached lookup</dt>
<dd>one call to a dynamic predicate (the cache entry)</dd>
<dt>checking for <em>after</em> events</dt>
<dd>one call to the built-in predicate <code class="docutils literal notranslate"><span class="pre">\+/1</span></code> and a call to its
argument, assuming that no events are defined</dd>
</dl>
<p>Given that events can be dynamically defined at runtime, there is no
room for reducing the number of predicate calls without turning off
support for event-driven programming. When events are defined, the
number of predicate calls grows proportional to the number of events and
event handlers (monitors). Event-driven programming support can be
switched off for specific object using the
<a class="reference internal" href="programming.html#flag-events"><span class="std std-ref">events</span></a> compiler flag. Doing so, reduces
the number of predicate calls from three to just one.</p>
<p>Messages to <em>self</em> are transparent regarding events and, as such, imply
only one predicate call (to the cache entry, a dynamic predicate).</p>
<p>When a message is sent by the user from the top-level interpreter,
Logtalk needs to perform a runtime translation of the message term in
order to prove the corresponding goal. Thus, while sending a message
from a compiled object corresponds to either three predicate calls
(event-support on) or one predicate call (event-support off), the same
message sent by the user from the top-level interpreter necessarily
implies an overhead. Considering the time taken for the user to type the
goal and read the reply, this overhead is of no practical consequence.</p>
<p>When a message is not cached, the number of predicate calls depends on
the number of steps needed for the Logtalk runtime engine to lookup the
corresponding predicate scope declaration (to check if the message is
valid) and then to lookup a predicate definition for answering the
message.</p>
</div>
<div class="section" id="processing-time">
<span id="messages-cputime"></span><h3>Processing time<a class="headerlink" href="#processing-time" title="Permalink to this headline">¶</a></h3>
<p>Not all predicate calls take the same time. Moreover, the time taken to
process a specific predicate call depends on the Prolog compiler
implementation details. As such, the only valid performance measure is
the time taken for processing a message.</p>
<p>The usual way of measuring the time taken by a predicate call is to
repeat the call a number of times and than to calculate the average
time. A sufficient large number of repetitions would hopefully lead to
an accurate measure. Care should be taken to subtract the time taken by
the repetition code itself. In addition, we should be aware of any
limitations of the predicates used to measure execution times. One way
to make sense of numbers we get is to repeat the test with the same
predicate using plain Prolog and with the predicate encapsulated in a
module.</p>
<p>A simple predicate for helping benchmarking predicate calls could be:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>benchmark(<span class="nv">N</span>, <span class="nv">Goal</span>) <span class="o">:-</span>
    <span class="k">repeat</span>(<span class="nv">N</span>),
        <span class="k">call</span>(<span class="nv">Goal</span>),
    <span class="k">fail</span>.

benchmark(<span class="nv">_</span>, <span class="nv">_</span>).
</pre></div>
</div>
<p>The rational of using a failure-driven loop is to try to avoid any
interference on our timing measurements from garbage-collection or
memory expansion mechanisms. Based on the predicate <code class="docutils literal notranslate"><span class="pre">benchmark/2</span></code>, we
may define a more convenient predicate for performing our benchmarks.
For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>benchmark(<span class="nv">Goal</span>) <span class="o">:-</span>
    <span class="c">% some sufficiently large number of repetitions</span>
    <span class="nv">N</span> <span class="o">=</span> <span class="m">10000000</span>,
    <span class="k">write</span>(<span class="s">&#39;Number of repetitions: &#39;</span>), <span class="k">write</span>(<span class="nv">N</span>), <span class="k">nl</span>,
    <span class="c">% replace by your Prolog-specific predicate</span>
    get_cpu_time(<span class="nv">Seconds1</span>),
    benchmark(<span class="nv">N</span>, <span class="nv">Goal</span>),
    get_cpu_time(<span class="nv">Seconds2</span>),
    <span class="nv">Average</span> <span class="k">is</span> (<span class="nv">Seconds2</span> <span class="o">-</span> <span class="nv">Seconds1</span>)<span class="o">/</span><span class="nv">N</span>,
    <span class="k">write</span>(<span class="s">&#39;Average time per call: &#39;</span>), <span class="k">write</span>(<span class="nv">Average</span>), <span class="k">write</span>(<span class="s">&#39; seconds&#39;</span>), <span class="k">nl</span>,
    <span class="nv">Speed</span> <span class="k">is</span> <span class="m">1.0</span><span class="o">/</span><span class="nv">Average</span>,
    <span class="k">write</span>(<span class="s">&#39;Number of calls per second: &#39;</span>), <span class="k">write</span>(<span class="nv">Speed</span>), <span class="k">nl</span>.
</pre></div>
</div>
<p>We can get a baseline for our timings by doing:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- benchmark(true).
</pre></div>
</div>
<p>For comparing message sending performance across several Prolog
compilers, we would call the <code class="docutils literal notranslate"><span class="pre">benchmark/1</span></code> predicate with a suitable
argument. For example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- benchmark(list::length([1,2,3,4,5,6,7,8,9,0], _)).
</pre></div>
</div>
<p>For comparing message sending performance with predicate calls in plain
Prolog and with calls to predicates encapsulated in modules, we should
use exactly the same predicate definition in the three cases.</p>
<p>It should be stressed that message sending is only one of the factors
affecting the performance of a Logtalk application (and often not the
most important one). The strengths and limitations of the chosen Prolog
compiler play a crucial role on all aspects of the development,
reliability, usability, and performance of a Logtalk application. It is
advisable to take advantage of the Logtalk wide compatibility with most
Prolog compilers to test for the best match for developing your Logtalk
applications.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="objects.html" class="btn btn-neutral float-right" title="Objects" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="nomenclature.html" class="btn btn-neutral" title="Nomenclature" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Paulo Moura

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>