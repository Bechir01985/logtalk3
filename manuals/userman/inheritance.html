

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Inheritance &mdash; Logtalk v3.21.0-b01 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/logtalk.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Event-driven programming" href="events.html" />
    <link rel="prev" title="Predicates" href="predicates.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Logtalk
          

          
          </a>

          
            
            
              <div class="version">
                3.21.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="features.html">Main features</a></li>
<li class="toctree-l2"><a class="reference internal" href="nomenclature.html">Nomenclature</a></li>
<li class="toctree-l2"><a class="reference internal" href="messages.html">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="categories.html">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">Predicates</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Inheritance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#protocol-inheritance">Protocol inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#search-order-for-prototype-hierarchies">Search order for prototype hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#search-order-for-class-hierarchies">Search order for class hierarchies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-inheritance">Implementation inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-implementation-prototype">Search order for prototype hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-implementation-class">Search order for class hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-versus-predicate-redefinition">Inheritance versus predicate redefinition</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#public-protected-and-private-inheritance">Public, protected, and private inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-versus-multiple-inheritance">Composition versus multiple inheritance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="events.html">Event-driven programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="threads.html">Multi-threading programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="errors.html">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="documenting.html">Documenting applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="installing.html">Installing Logtalk</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming.html">Writing, running, and debugging applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="migration.html">Prolog Integration and Migration Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Logtalk</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">User Manual</a> &raquo;</li>
        
      <li>Inheritance</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/userman/inheritance.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="inheritance">
<span id="inheritance-inheritance"></span><h1>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h1>
<p>The inheritance mechanisms found on object-oriented programming
languages allow us the specialization of previously defined objects,
avoiding the unnecessary repetition of code. In the context of logic
programming, we can interpret inheritance as a form of theory extension:
an object will virtually contain, besides its own predicates, all the
predicates inherited from other objects that are not redefined by
itself.</p>
<p>Logtalk uses a depth-first lookup procedure for finding predicate
declarations and predicate definitions, as explained below. The lookup
procedures locate the entities holding the predicate declaration and the
predicate definition using, respectively, the predicate indicator and
the predicate template (constructed from the predicate indicator).</p>
<p>The <a class="reference internal" href="../refman/directives/alias_2.html#directives-alias-2"><span class="std std-ref">alias/2</span></a> predicate
directive may be used to defining alternative names for inherited
predicates, for solving inheritance conflicts, and for giving access to
all inherited definitions.</p>
<div class="section" id="protocol-inheritance">
<span id="inheritance-protocol"></span><h2>Protocol inheritance<a class="headerlink" href="#protocol-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Protocol inheritance refers to the inheritance of predicate declarations
(scope directives). These can be contained in objects, in protocols, or
in categories. Logtalk supports single and multi-inheritance of
protocols: an object or a category may implement several protocols and a
protocol may extend several protocols.</p>
<div class="section" id="search-order-for-prototype-hierarchies">
<span id="inheritance-protocol-prototype"></span><h3>Search order for prototype hierarchies<a class="headerlink" href="#search-order-for-prototype-hierarchies" title="Permalink to this headline">¶</a></h3>
<p>The search order for predicate declarations is first the object, second
the implemented protocols (and the protocols that these may extend),
third the imported categories (and the protocols that they may
implement), and last the objects that the object extends. This search is
performed in a depth-first way. When an object inherits two different
declarations for the same predicate, by default, only the first one will
be considered.</p>
</div>
<div class="section" id="search-order-for-class-hierarchies">
<span id="inheritance-protocol-class"></span><h3>Search order for class hierarchies<a class="headerlink" href="#search-order-for-class-hierarchies" title="Permalink to this headline">¶</a></h3>
<p>The search order for predicate declarations starts in the object
classes. Following the classes declaration order, the search starts in
the classes implemented protocols (and the protocols that these may
extend), third the classes imported categories (and the protocols that
they may implement), and last the superclasses of the object classes.
This search is performed in a depth-first way. If the object inherits
two different declarations for the same predicate, by default only the
first one will be considered.</p>
</div>
</div>
<div class="section" id="implementation-inheritance">
<span id="inheritance-implementation"></span><h2>Implementation inheritance<a class="headerlink" href="#implementation-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Implementation inheritance refers to the inheritance of predicate
definitions. These can be contained in objects or in categories. Logtalk
supports multi-inheritance of implementation: an object may import
several categories or extend, specialize, or instantiate several
objects.</p>
<div class="section" id="inheritance-implementation-prototype">
<span id="id1"></span><h3>Search order for prototype hierarchies<a class="headerlink" href="#inheritance-implementation-prototype" title="Permalink to this headline">¶</a></h3>
<p>The search order for predicate definitions is similar to the search for
predicate declarations except that implemented protocols are ignored (as
they can only contain predicate directives).</p>
</div>
<div class="section" id="inheritance-implementation-class">
<span id="id2"></span><h3>Search order for class hierarchies<a class="headerlink" href="#inheritance-implementation-class" title="Permalink to this headline">¶</a></h3>
<p>The search order for predicate definitions is similar to the search for
predicate declarations except that implemented protocols are ignored (as
they can only contain predicate directives) and that the search starts
at the instance itself (that received the message) before proceeding, if
no predicate definition is found there, to the instance classes and then
to the class superclasses.</p>
</div>
<div class="section" id="inheritance-versus-predicate-redefinition">
<span id="inheritance-implementation-redefinition"></span><h3>Inheritance versus predicate redefinition<a class="headerlink" href="#inheritance-versus-predicate-redefinition" title="Permalink to this headline">¶</a></h3>
<p>When we define a predicate that is already inherited from other object,
the inherited definitions are hidden by the new definitions. This is
called overriding inheritance: a local definition overrides any
inherited ones. For example, assume that we have the following two
objects:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(bar<span class="o">/</span><span class="m">1</span>).
<span class="p">    :- </span><span class="k">public</span>(foo<span class="o">/</span><span class="m">1</span>).

    bar(root).

    foo(root).

<span class="p">:- </span><span class="k">end_object.</span>


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    foo(descendant).

<span class="p">:- </span><span class="k">end_object.</span>
</pre></div>
</div>
<p>After compiling and loading these objects, we can check the overriding
behavior by trying the following queries:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- root::(bar(Bar), foo(Foo)).

Bar = root
Foo = root
yes


| ?- descendant::(bar(Bar), foo(Foo)).

Bar = root
Foo = descendant
yes
</pre></div>
</div>
<p>However, we can explicitly program other behaviors. Let us see a few
examples.</p>
<div class="section" id="specialization-inheritance">
<span id="inheritance-specialization"></span><h4>Specialization inheritance<a class="headerlink" href="#specialization-inheritance" title="Permalink to this headline">¶</a></h4>
<p>Specialization of inherited definitions: the new definition uses the
inherited definitions, adding to this new code. This is accomplished by
calling the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a> operator
in the new definition.</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(init<span class="o">/</span><span class="m">0</span>).

    init <span class="o">:-</span>
        <span class="k">write</span>(<span class="s">&#39;root init&#39;</span>), <span class="k">nl</span>.

<span class="p">:- </span><span class="k">end_object.</span>


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    init <span class="o">:-</span>
        <span class="k">write</span>(<span class="s">&#39;descendant init&#39;</span>), <span class="k">nl</span>,
        <span class="o">^^</span>init.

<span class="p">:- </span><span class="k">end_object.</span>


| <span class="o">?-</span> descendant<span class="o">::</span>init.

descendant init
root init

yes
</pre></div>
</div>
</div>
<div class="section" id="union-inheritance">
<span id="inheritance-union"></span><h4>Union inheritance<a class="headerlink" href="#union-inheritance" title="Permalink to this headline">¶</a></h4>
<p>Union of the new with the inherited definitions: all the definitions are
taken into account, the calling order being defined by the inheritance
mechanisms. This can be accomplished by writing a clause that just
calls, using the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a>
operator, the inherited definitions. The relative position of this
clause among the other definition clauses sets the calling order for the
local and inherited definitions.</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(foo<span class="o">/</span><span class="m">1</span>).

    foo(<span class="m">1</span>).
    foo(<span class="m">2</span>).

<span class="p">:- </span><span class="k">end_object.</span>


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    foo(<span class="m">3</span>).
    foo(<span class="nv">Foo</span>) <span class="o">:-</span>
        <span class="o">^^</span>foo(<span class="nv">Foo</span>).

<span class="p">:- </span><span class="k">end_object.</span>


| <span class="o">?-</span> descendant<span class="o">::</span>foo(<span class="nv">Foo</span>).

<span class="nv">Foo</span> <span class="o">=</span> <span class="m">3</span> <span class="o">;</span>
<span class="nv">Foo</span> <span class="o">=</span> <span class="m">1</span> <span class="o">;</span>
<span class="nv">Foo</span> <span class="o">=</span> <span class="m">2</span> <span class="o">;</span>
no
</pre></div>
</div>
</div>
<div class="section" id="selective-inheritance">
<span id="inheritance-selective"></span><h4>Selective inheritance<a class="headerlink" href="#selective-inheritance" title="Permalink to this headline">¶</a></h4>
<p>Hiding some of the inherited definitions, or differential inheritance:
this form of inheritance is normally used in the representation of
exceptions to generic definitions. Here we will need to use the
<a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a> operator to test and
possibly reject some of the inherited definitions.</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(bird).

<span class="p">    :- </span><span class="k">public</span>(mode<span class="o">/</span><span class="m">1</span>).

    mode(walks).
    mode(flies).

<span class="p">:- </span><span class="k">end_object.</span>


<span class="p">:- </span><span class="k">object</span>(penguin,
    <span class="k">extends</span>(bird)).

    mode(swims).
    mode(<span class="nv">Mode</span>) <span class="o">:-</span>
        <span class="o">^^</span>mode(<span class="nv">Mode</span>),
        <span class="nv">Mode</span> <span class="o">\=</span> flies.

<span class="p">:- </span><span class="k">end_object.</span>


| <span class="o">?-</span> penguin<span class="o">::</span>mode(<span class="nv">Mode</span>).

<span class="nv">Mode</span> <span class="o">=</span> swims <span class="o">;</span>
<span class="nv">Mode</span> <span class="o">=</span> walks <span class="o">;</span>

no
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="public-protected-and-private-inheritance">
<span id="inheritance-types"></span><h2>Public, protected, and private inheritance<a class="headerlink" href="#public-protected-and-private-inheritance" title="Permalink to this headline">¶</a></h2>
<p>To make all <a class="reference internal" href="../glossary.html#term-public-predicate"><span class="xref std std-term">public predicates</span></a>
declared via implemented protocols, imported categories, or ancestor
objects <a class="reference internal" href="../glossary.html#term-protected-predicate"><span class="xref std std-term">protected predicates</span></a> or to make
all public and protected predicates
<a class="reference internal" href="../glossary.html#term-private-predicate"><span class="xref std std-term">private predicates</span></a> we prefix the entity’s
name with the corresponding keyword. For instance:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">implements</span>(private<span class="o">::</span><span class="nv">Protocol</span>)).

    <span class="c">% all the Protocol public and protected</span>
    <span class="c">% predicates become private predicates</span>
    <span class="c">% for the Object clients</span>

    ...

<span class="p">:- </span><span class="k">end_object.</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Class</span>,
    <span class="k">specializes</span>(protected<span class="o">::</span><span class="nv">Superclass</span>)).

    <span class="c">% all the Superclass public predicates become</span>
    <span class="c">% protected predicates for the Class clients</span>

    ...

<span class="p">:- </span><span class="k">end_object.</span>
</pre></div>
</div>
<p>Omitting the scope keyword is equivalent to using the public scope
keyword. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">imports</span>(public<span class="o">::</span><span class="nv">Category</span>)).
    ...
<span class="p">:- </span><span class="k">end_object.</span>
</pre></div>
</div>
<p>This is the same as:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">imports</span>(<span class="nv">Category</span>)).
    ...
<span class="p">:- </span><span class="k">end_object.</span>
</pre></div>
</div>
<p>This way we ensure backward compatibility with older Logtalk versions
and a simplified syntax when protected or private inheritance are not
used.</p>
</div>
<div class="section" id="composition-versus-multiple-inheritance">
<span id="inheritance-composition"></span><h2>Composition versus multiple inheritance<a class="headerlink" href="#composition-versus-multiple-inheritance" title="Permalink to this headline">¶</a></h2>
<p>It is not possible to discuss inheritance mechanisms without referring
to the long and probably endless debate on single versus multiple
inheritance. The single inheritance mechanism can be implemented in an
very efficient way, but it imposes several limitations on reusing, even
if the multiple characteristics we intend to inherit are orthogonal. On
the other hand, the multiple inheritance mechanisms are attractive in
their apparent capability of modeling complex situations. However, they
include a potential for conflict between inherited definitions whose
variety does not allow a single and satisfactory solution for all the
cases.</p>
<p>Until now, no solution that we might consider satisfactory for all the
problems presented by the multiple inheritance mechanisms has been
found. From the simplicity of some extensions that use the Prolog search
strategy like <a class="reference internal" href="../bibliography.html#mccabe92" id="id3">[McCabe92]</a> or <a class="reference internal" href="../bibliography.html#moss94" id="id4">[Moss94]</a> and to the sophisticated algorithms
of CLOS <a class="reference internal" href="../bibliography.html#bobrow-et-al-88" id="id5">[Bobrow_et_al_88]</a>, there is no
adequate solution for all the situations. Besides, the use of multiple
inheritance carries some complex problems in the domain of software
engineering, particularly in the reuse and maintenance of the
applications. All these problems are substantially reduced if we
preferably use in our software development composition mechanisms
instead of specialization mechanisms <a class="reference internal" href="../bibliography.html#taenzer89" id="id6">[Taenzer89]</a>. Multiple inheritance can and
should be seen more as a useful analysis and project abstraction, than
as an implementation technique <a class="reference internal" href="../bibliography.html#shan-et-al-93" id="id7">[Shan_et_al_93]</a>. Logtalk provides first-class
support for software composition using <a class="reference internal" href="categories.html#categories-categories"><span class="std std-ref">Categories</span></a>.</p>
<p>Nevertheless, Logtalk supports multi-inheritance by enabling an object
to extend, instantiate, or specialize more than one object. The current
Logtalk release provides a predicate directive,
<a class="reference internal" href="../refman/directives/alias_2.html#directives-alias-2"><span class="std std-ref">alias/2</span></a>, which may be used
to solve some multi-inheritance conflicts. Lastly, it should be noted
that the multi-inheritance support does not affect performance when we
use single-inheritance.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="events.html" class="btn btn-neutral float-right" title="Event-driven programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="predicates.html" class="btn btn-neutral" title="Predicates" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Paulo Moura.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'v3.21.0-b01',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>