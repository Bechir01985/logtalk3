<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<!--
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  This file is part of Logtalk <http://logtalk.org/>    
%  Copyright 1998-2015 Paulo Moura <pmoura@logtalk.org>
%
%  Licensed under the Apache License, Version 2.0 (the "License");
%  you may not use this file except in compliance with the License.
%  You may obtain a copy of the License at
%
%      http://www.apache.org/licenses/LICENSE-2.0
%
%  Unless required by applicable law or agreed to in writing, software
%  distributed under the License is distributed on an "AS IS" BASIS,
%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%  See the License for the specific language governing permissions and
%  limitations under the License.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk user manual: categories</title>
	<link rel="stylesheet" href="../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk user manual</div>
<div class="top-right">Categories</div>
<div class="bottom-left"><span class="page"/></div>
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../index.html">Contents</a> &gt; <a href="index.html">User Manual</a> &gt; Categories</div>

<h1 id="categories_categories">Categories</h1>

<p>
Categories are fine-grained units of code reuse and can be regarded as a dual concept of protocols. Categories provide a way to encapsulate a set of related predicate declarations and definitions that do not represent a complete object and that only make sense when composed with other predicates. Categories may also be used to break a complex object in functional units. A category can be imported by several objects (without code duplication), including objects participating in prototype or class-based hierarchies. This concept of categories shares some ideas with Smalltalk-80 functional categories <a href="../bibliography.html#Goldberg83">[Goldberg 83]</a>, Flavors mix-ins <a href="../bibliography.html#Moon86">[Moon 86]</a> (without necessarily implying multi-inheritance), and Objective-C categories <a href="../bibliography.html#Cox86">[Cox 86]</a>. Categories may also <em>complement</em> existing objects, thus providing a hot patching mechanism inspired by the Objective-C categories functionality.
</p>

<h2 id="categories_defining">Defining a new category</h2>

<p>
We can define a new category in the same way we write Prolog code: by using a text editor. Logtalk source files may contain one or more objects, categories, or protocols. If you prefer to define each entity in its own source file, it is recommended that the file be named after the category. By default, all Logtalk source files use the extension <code>.lgt</code> but this is optional and can be set in the adapter files. Intermediate Prolog source files (generated by the Logtalk compiler) have, by default, a <code>_lgt</code> suffix and a <code>.pl</code> extension. Again, this can be set to match the needs of a particular Prolog compiler in the corresponding adapter file. For instance, we may define a category named <code>documenting</code> and save it in a <code>documenting.lgt</code> source file that will be compiled to a <code>documenting_lgt.pl</code> Prolog file.
</p>
<p>
Category names can be atoms or compound terms (when defining parametric categories). Objects, categories, and protocols share the same name space: we cannot have a category with the same name as an object or a protocol.
</p>
<p>
Category code (directives and predicates) is textually encapsulated by using two Logtalk directives: <a title="Consult reference manual" href="../refman/directives/category_1_3.html"><code>category/1-3</code></a> and <a title="Consult reference manual" href="../refman/directives/end_category_0.html"><code>end_category/0</code></a>. The most simple category will be one that is self-contained, not depending on any other Logtalk entity:
</p>
<pre>:- category(Category).
    ...
:- end_category.</pre>
<p>
If a category implements one or more protocols then the opening directive will be:
</p>
<pre>:- category(Category,
    implements(Protocol1, Protocol2, ...)).
    ...
:- end_category.</pre>
<p>
A category may be defined as a composition of other categories by writing:
</p>
<pre>:- category(Category,
    extends(Category1, Category2, ...)).
    ...
:- end_category.</pre>
<p>
This feature should only be used when extending a category without breaking its functional cohesion (for example, when a modified version of a category is needed for importing on several unrelated objects). The preferred way of composing several categories is by importing them into an object. When a category overrides a predicate defined in an extended category, the overridden definition can still be used by using the <a title="Consult reference manual" href="../refman/directives/alias_2.html"><code>alias/2</code></a> predicate directive.
</p>
<p>
Categories cannot inherit from objects. In addition, categories cannot define clauses for dynamic predicates. This restriction applies because a category can be imported by several objects and because we cannot use the database handling built-in methods with categories (messages can only be sent to objects). However, categories may contain declarations for dynamic predicates and they can contain predicates which handle dynamic predicates. For example:
</p>
<pre>:- category(attributes).

    :- public(attribute/2).
    :- public(set_attribute/2).
    :- public(del_attribute/2).

    :- private(attribute_/2).
    :- dynamic(attribute_/2).

    attribute(Attribute, Value) :-
        ::attribute_(Attribute, Value).          % called in the context of "self"

    set_attribute(Attribute, Value) :-
        ::retractall(attribute_(Attribute, _)),  % retracts clauses in "self"
        ::assertz(attribute_(Attribute, Value)). % asserts clause in "self"

    del_attribute(Attribute, Value) :-
        ::retract(attribute_(Attribute, Value)). % retracts clause in "self"

:- end_category.</pre>
<p>
Each object importing this category will have its own <code>attribute_/2</code> private, dynamic predicate. The predicates <code>attribute/2</code>, <code>set_attribute/2</code>, and <code>del_attribute/2</code> always access and modify the dynamic predicate contained in the object receiving the corresponding messages (i.e. <em>self</em>). But it's also possible to define predicates that handle dynamic predicates in the context of <em>this</em> instead of <em>self</em>. For example:
</p>
<pre>:- category(attributes).

    :- public(attribute/2).
    :- public(set_attribute/2).
    :- public(del_attribute/2).

    :- private(attribute_/2).
    :- dynamic(attribute_/2).

    attribute(Attribute, Value) :-
        attribute_(Attribute, Value).            % called in the context of "this"

    set_attribute(Attribute, Value) :-
        retractall(attribute_(Attribute, _)),    % retracts clauses in "this"
        assertz(attribute_(Attribute, Value)).   % asserts clause in "this"

    del_attribute(Attribute, Value) :-
        retract(attribute_(Attribute, Value)).   % retracts clause in "this"

:- end_category.</pre>
<p>
When defining a category that declares and handles dynamic predicates, working in the context of <em>this</em> ties those dynamic predicates to the object importing the category while working in the context of <em>self</em> allows each object inheriting from the object that imports the category to have its own set of clauses for those dynamic predicates.
</p>

<h3 id="categories_patching">Hot patching</h3>

<p>
A category may explicitly complement one or more existing objects, thus providing hot patching functionality inspired by Objective-C categories:
</p>
<pre>:- category(Category,
    complements(Object1, Object2, ....)).
    ...
:- end_category.</pre>
<p>
This allows us to add missing directives (e.g. to define aliases for complemented object predicates), replace broken predicate definitions, add new predicates, and add protocols and categories to existing objects without requiring access or modifications to their source code. Common scenarios are adding logging or debugging predicates to a set of objects. Complemented objects need to be compiled with the <code>complements</code> compiler flag set <code>allow</code> (to allow both patching and adding functionality) or <code>restrict</code> (to allow only adding new functionality). A complementing category takes preference over a previously
loaded complementing category for the same object thus allowing patching a previous patch if necessary.
</p>
<p>
An unfortunate consequence of allowing an object to be patched at runtime using a complementing category is that it disables the use of static binding optimizations for messages sent to the complemented object as it can always be later patched, thus rendering the static binding optimizations invalid.
</p>

<h2 id="categories_finding">Finding defined categories</h2>

<p>
We can find, by backtracking, all defined categories by using the <a title="Consult reference manual" href="../refman/predicates/current_category_1.html"><code>current_category/1</code></a> Logtalk built-in predicate with a non-instantiated variable:
</p>
<pre>| ?- current_category(Category).</pre>
<p>
This predicate can also be used to test if a category is defined by calling it with a valid category identifier (an atom or a compound term).
</p>

<h2 id="categories_creating">Creating a new category in runtime</h2>

<p>
A category can be dynamically created at runtime by using the <a title="Consult reference manual" href="../refman/predicates/create_category_4.html"><code>create_category/4</code></a> built-in predicate:
</p>
<pre>| ?- create_category(Category, Relations, Directives, Clauses).</pre>
<p>
The first argument should be either a variable or the name of the new category (a Prolog atom, which must not match with an existing entity name). The remaining three arguments correspond to the relations described in the opening category directive and to the category code contents (directives and clauses).
</p>
<p>
For instance, the call:
</p>
<pre>| ?- create_category(ccc,
                     [implements(ppp)],
                     [private(bar/1)],
                     [(foo(X):-bar(X)), bar(1), bar(2)]).</pre>
<p>
is equivalent to compiling and loading the category:
</p>
<pre>:- category(ccc,
    implements(ppp)).

    :- dynamic.

    :- private(bar/1).

    foo(X) :-
        bar(X).

    bar(1).
    bar(2).

:- end_category.</pre>
<p>
If we need to create a lot of (dynamic) categories at runtime, then is best to to define a metaclass or a prototype with a predicate that will call this built-in predicate in order to provide more sophisticated behavior.
</p>

<h2 id="categories_abolishing">Abolishing an existing category</h2>

<p>
Dynamic categories can be abolished using the <a title="Consult reference manual" href="../refman/predicates/abolish_category_1.html"><code>abolish_category/1</code></a> built-in predicate:
</p>
<pre>| ?- abolish_category(Category).</pre>
<p>
The argument must be an identifier of a defined dynamic category, otherwise an error will be thrown.
</p>

<h2 id="categories_directives">Category directives</h2>

<p>
Category directives are used to define category properties, to document a category dependencies on other Logtalk entities, and to load the contents of files into a category.
</p>

<h3 id="categories_dynamic">Dynamic categories</h3>

<p>
As usually happens with Prolog code, a category can be either static or dynamic. A category created during the execution of a program is always dynamic. A category defined in a file can be either dynamic or static. Dynamic categories are declared by using the <a title="Consult reference manual" href="../refman/directives/dynamic_0.html"><code>dynamic/0</code></a> directive in the category source code:
</p>
<pre>:- dynamic.</pre>
<p>
The directive must precede any predicate directives or clauses. Please be aware that using dynamic code results in a performance hit when compared to static code. We should only use dynamic categories when these need to be abolished during program execution.
</p>

<h3 id="categories_documentation">Category documentation</h3>

<p>
A category can be documented with arbitrary user-defined information by using the <a title="Consult reference manual" href="../refman/directives/info_1.html"><code>info/1</code></a> directive:
</p>
<pre>:- info(List).</pre>
<p>
See the <a href="documenting.html">documenting Logtalk programs</a> section for details.
</p>

<h3 id="categories_include">Loading files into a category</h3>

<p>
The <a title="Consult reference manual" href="../refman/directives/include_1.html"><code>include/1</code></a> directive can be used to load the contents of a file into a category. See the <a href="objects.html">objects</a> section for an example of using this directive.
</p>

<h2 id="categories_relationships">Category relationships</h2>

<p>
Logtalk provides two sets of built-in predicates that enable us to query the system about the possible relationships that a category can have with other entities.
</p>
<p>
The built-in predicates <a title="Consult reference manual" href="../refman/predicates/implements_protocol_2_3.html"><code>implements_protocol/2-3</code></a> and <a title="Consult reference manual" href="../refman/predicates/conforms_to_protocol_2_3.html"><code>conforms_to_protocol/2-3</code></a> allows us to find which categories implements which protocols:
</p>
<pre>| ?- implements_protocol(Category, Protocol, Scope).</pre>
<p>
or, if we also want inherited protocols:
</p>
<pre>| ?- conforms_to_protocol(Category, Protocol, Scope).</pre>
<p>
Note that, if we use a non-instantiated variable for the first argument, we will need to use the <a title="Consult reference manual" href="../refman/predicates/current_category_1.html"><code>current_category/1</code></a> built-in predicate to ensure that the returned entity is a category and not an object.
</p>
<p>
To find which objects import which categories we can use the 
<a title="Consult reference manual" href="../refman/predicates/imports_category_2_3.html"><code>imports_category/2</code></a> or <a title="Consult reference manual" href="../refman/predicates/imports_category_2_3.html"><code>imports_category/3</code></a> built-in predicates:
</p>
<pre>| ?- imports_category(Object, Category).</pre>
<p>
or, if we want to know the importation scope:
</p>
<pre>| ?- imports_category(Object, Category, Scope).</pre>
<p>
Note that a category may be imported by several objects.
</p>
<p>
To find which categories extend other categories we can use the 
<a title="Consult reference manual" href="../refman/predicates/extends_category_2_3.html"><code>extends_category/2</code></a> or <a title="Consult reference manual" href="../refman/predicates/extends_category_2_3.html"><code>extends_category/3</code></a> built-in predicates:
</p>
<pre>| ?- extends_category(Category1, Category2).</pre>
<p>
or, if we want to know the extension scope:
</p>
<pre>| ?- extends_category(Category1, Category2, Scope).</pre>
<p>
Note that a category may be extended by several categories.
</p>
<p>
To find which categories explicitly complement existing objects we can use the 
<a title="Consult reference manual" href="../refman/predicates/complements_object_2.html"><code>complements_object/2</code></a> built-in predicate:
</p>
<pre>| ?- complements_object(Category, Object).</pre>
<p>
Note that a category may explicitly complement several objects.
</p>

<h2 id="categories_properties">Category properties</h2>

<p>
We can find the properties of defined categories by calling the built-in predicate <a title="Consult reference manual" href="../refman/predicates/category_property_2.html"><code>category_property/2</code></a>:
</p>
<pre>| ?- category_property(Category, Property).</pre>
<p>
The following category properties are supported:
</p>
<dl>
	<dt><code>static</code></dt>
		<dd>The category is static</dd>
	<dt><code>dynamic</code></dt>
		<dd>The category is dynamic (and thus can be abolished in runtime by calling the <a title="Consult reference manual" href="../refman/predicates/abolish_category_1.html"><code>abolish_category/1</code></a> built-in predicate)</dd>
	<dt><code>built_in</code></dt>
		<dd>The category is a built-in category (and thus always available)</dd>
	<dt><code>file(Path)</code></dt>
		<dd>Absolute path of the source file defining the category (if applicable)</dd>
	<dt><code>file(Basename, Directory)</code></dt>
		<dd>Basename and directory of the source file defining the category (if applicable)</dd>
	<dt><code>lines(BeginLine, EndLine)</code></dt>
		<dd>Source file begin and end lines of the category definition (if applicable)</dd>
	<dt><code>events</code></dt>
		<dd>Messages sent from the category generate events</dd>
	<dt><code>source_data</code></dt>
		<dd>Source data available for the category</dd>
	<dt><code>public(Predicates)</code></dt>
		<dd>List of public predicates declared by the category</dd>
	<dt><code>protected(Predicates)</code></dt>
		<dd>List of protected predicates declared by the category</dd>
	<dt><code>private(Predicates)</code></dt>
		<dd>List of private predicates declared by the category</dd>
	<dt><code>declares(Predicate, Properties)</code></dt>
		<dd>List of properties for a predicate declared by the category</dd>
	<dt><code>defines(Predicate, Properties)</code></dt>
		<dd>List of properties for a predicate defined by the category</dd>
	<dt><code>includes(Predicate, Entity, Properties)</code></dt>
		<dd>List of properties for an object multifile predicate that are defined in the specified entity (the properties include <code>number_of_clauses(Number)</code> and <code>line_count(Line)</code> with <code>Line</code> being the begin line of the multifile predicate clause)</dd>
	<dt><code>provides(Predicate, Entity, Properties)</code></dt>
		<dd>List of properties for other entity multifile predicate that are defined in the category (the properties include <code>number_of_clauses(Number)</code> and <code>line_count(Line)</code> with <code>Line</code> being the begin line of the multifile predicate clause)</dd>
	<dt><code>alias(Predicate, Properties)</code></dt>
		<dd>List of properties for a predicate alias declared by the category (the properties include <code>for(Original)</code>, <code>from(Entity)</code>, <code>non_terminal(NonTerminal)</code>, and <code>line_count(Line)</code> with <code>Line</code> being the begin line of the alias directive)</dd>
	<dt><code>calls(Call, Properties)</code></dt>
		<dd>List of properties for predicate calls made by the category (<code>Call</code> is either a predicate indicator or a control construct such as <code>^^/1</code> with a predicate indicator as argument; note that <code>Call</code> may not be ground when the control construct is <code>::/2</code> and the object argument is only know at runtime; the properties include <code>caller(Caller)</code> and <code>line_count(Line)</code> with <code>Caller</code> being a predicate indicator and <code>Line</code> being the begin line of the predicate clause or directive making the call)</dd>
	<dt><code>number_of_clauses(Number)</code></dt>
		<dd>Total number of predicate clauses defined in the category (includes both user-defined clauses and auxiliary clauses generated by the compiler or by expansion hooks)</dd>
	<dt><code>number_of_user_clauses(Number)</code></dt>
		<dd>Total number of user-defined predicate clauses defined in the category</dd>
</dl>
<p>
Some of the properties such as line numbers are only available when the category is defined in a source file compiled with the <code>source_data</code> flag turned on.
</p>

<h2 id="categories_importing">Importing categories</h2>

<p>
Any number of objects can import a category. In addition, an object may import any number of categories. The syntax is very simple:
</p>
<pre>:- object(Object,
    imports(Category1, Category2, ...)).
    ...
:- end_object.</pre>
<p>
To make all public predicates imported via a category protected or to make all public and protected predicates private we prefix the category's name with the corresponding keyword:
</p>
<pre>:- object(Object,
    imports(private::Category)).
    ...
:- end_object.</pre>
<p>
or:
</p>
<pre>:- object(Object,
    imports(protected::Category)).
    ...
:- end_object.</pre>
<p>
Omitting the scope keyword is equivalent to writing:
</p>
<pre>:- object(Object,
    imports(public::Category)).
    ...
:- end_object.</pre>

<h2 id="categories_predicates">Using category predicates</h2>

<p>
Category predicates can be called from within an object using either the message sending mechanisms or a direct call. Consider the following category:
</p>
<pre>:- category(output).

    :- public(out/1).

    out(X) :-
        writeq(X), nl.

:- end_category.</pre>
<p>
Using the message sending mechanisms, the predicate <code>out/1</code> can be called from within an object importing the category by simply sending a message to <em>self</em>. For example:
</p>
<pre>:- object(worker,
    imports(output)).

    ...
    do(Task) :-
        execute(Task, Result),
        ::out(Result).
    ...

:- end_object.</pre>
<p>
This is the recommended way of calling category predicates as it supports the specialization/redefinition of the category predicate in a descendant object (as the predicate declaration and definition lookups will start from <em>self</em>). Messages to <em>self</em> usually imply the use of dynamic binding as the actual object that will receive the message is only known at runtime. This translates to a small performance penalty when compared with calls to local object predicates.
</p>
<p>
It is also possible to perform direct calls to predicates from imported categories without using the message sending mechanisms with the <a title="Consult reference manual" href="../refman/control/call_super_1.html"><code>^^/1</code></a> control construct. For example:
</p>
<pre>:- object(worker,
    imports(output)).

    ...
    do(Task) :-
        execute(Task, Result),
        ^^out(Result).
    ...

:- end_object.</pre>
<p>
This alternative should only be used when the user knows a priori that the category predicates will not be specialized or redefined by descendant objects of the object importing the category. Its advantage is that, when the <code>optimize</code> compiler flag is turned on, the Logtalk compiler will try to optimize the calls by using static binding. When dynamic binding is used due to e.g. the lack of sufficient information at compilation time, the performance is similar to calling the category predicate using a message to <em>self</em> (in both cases a predicate lookup caching mechanism is used).
</p>

<h2 id="categories_parametric">Parametric categories</h2>

<p>
Category predicates can be parameterized in the same way as object predicates by using a compound term as the category identifier and by calling the <a title="Consult reference manual" href="../refman/methods/parameter_2.html"><code>parameter/2</code></a> built-in local method in the category predicate clauses. Category parameter values can be defined by the importing objects. For example:
</p>
<pre>:- object(speech(Season, Event),
    imports(dress(Season), speech(Event))).

    ...

:- end_object.</pre>
<p>
Note that access to category parameters is only possible using the <code>parameter/2</code> method from within the category. Calls to the <a title="Consult reference manual" href="../refman/methods/this_1.html"><code>this/1</code></a> built-in local method from category predicates always access the importing object identifier (and thus object parameters, not category parameters).
</p>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>
		<span>Last updated on: October 1, 2015</span>
	</div>
	<div class="navbottom">
		<span><a href="protocols.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="predicates.html">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
