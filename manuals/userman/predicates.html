<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<!--
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  
%  This file is part of Logtalk <http://logtalk.org/>    
%  Copyright (c) 1998-2015 Paulo Moura <pmoura@logtalk.org>
%  
%  Logtalk is free software. You can redistribute it and/or modify it under
%  the terms of the FSF GNU General Public License 3  (plus some additional
%  terms per section 7).        Consult the `LICENSE.txt` file for details.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk user manual: predicates</title>
	<link rel="stylesheet" href="../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk user manual</div>
<div class="top-right">Predicates</div>
<div class="bottom-left"><span class="page"/></div>
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../index.html">Contents</a> &gt; <a href="index.html">User Manual</a> &gt; Predicates</div>

<h1 id="predicates_predicates">Predicates</h1>

<p>
Predicate directives and clauses can be encapsulated inside objects and categories. Protocols can only contain predicate directives. From the point-of-view of an object-oriented language, predicates allows both object state and object behavior to be represented. Mutable object state can be represented using dynamic object predicates.
</p>

<h2 id="predicates_reserved">Reserved predicate names</h2>

<p>
For performance reasons, a few predicates have a fixed interpretation. These predicates are declared in the built-protocols. They are: <code>goal_expansion/2</code> and <code>term_expansion/2</code>, declared in the <code>expanding</code> protocol; <code>before/3</code> and <code>after/3</code>, declared in the <code>monitoring</code> protocol; and <code>forward/1</code>, declared in the <code>forwarding</code> protocol. By default, the compiler prints a warning when a definition for one of these predicates are found but the reference to the corresponding built-in protocol is missing.
</p>

<h2 id="predicates_declaring">Declaring predicates</h2>

<p>
All object (or category) predicates that we want to access from other objects must be explicitly declared. A predicate declaration must contain, at least, a scope directive. Other directives may be used to document the predicate or to ensure proper compilation of the predicate definitions.
</p>
<p>
Predicate directives should always precede the corresponding predicate definitions and/or calls in the source files in order to ensure proper compilation.
</p>

<h3 id="predicates_scope">Scope directives</h3>

<p>
A predicate can be <em>public</em>, <em>protected</em>, <em>private</em>, or <em>local</em>. Public predicates can be called from any object. Protected predicates can only be called from the container object or from a container descendant. Private predicates can only be called from the container object. Local predicates, like private predicates, can only be called from the container object (or category) but they are <em>invisible</em> to the reflection built-in methods (<code>current_op/3</code>, <code>current_predicate/1</code>, and <code>predicate_property/2</code>) and to the message error handling mechanisms (i.e. sending a message corresponding to a local predicate results in a <code>predicate_declaration</code> existence error, not in a scope error).
</p>
<p>
The scope declarations are made using the directives <a title="Consult reference manual" href="../refman/directives/public_1.html"><code>public/1</code></a>, <a title="Consult reference manual" href="../refman/directives/protected_1.html"><code>protected/1</code></a>, and <a title="Consult reference manual" href="../refman/directives/private_1.html"><code>private/1</code></a>. For example:
</p>
<pre>:- public(init/1).

:- protected(valid_init_option/1).

:- private(process_init_options/1).</pre>
<p>
If a predicate does not have a scope declaration, it is assumed that the predicate is local. Note that we do not need to write scope declarations for all defined predicates. One exception is local dynamic predicates: declaring them as private predicates may allow the Logtalk compiler to generate optimized code for asserting and retracting clauses.
</p>

<h3 id="predicates_mode">Mode directive</h3>

<p>
Many predicates cannot be called with arbitrary arguments with arbitrary instantiation status. The valid arguments and instantiation modes can be documented by using the <a title="Consult reference manual" href="../refman/directives/mode_2.html"><code>mode/2</code></a> directive. For instance:
</p>
<pre>:- mode(member(?term, +list), zero_or_more).</pre>
<p>
The first argument describes a valid calling mode. The minimum information will be the instantiation mode of each argument. There are four possible values (described in <a title="ISO Prolog Standard" href="../bibliography.html#ISO95">[ISO 95]</a>):
</p>
<dl>
	<dt><code>+</code></dt>
		<dd>Argument must be instantiated.</dd>
	<dt><code>-</code></dt>
		<dd>Argument must be a free (non-instantiated) variable.</dd>
	<dt><code>?</code></dt>
		<dd>Argument can either be instantiated or free.</dd>
	<dt><code>@</code></dt>
		<dd>Argument will not be modified.</dd>
</dl>
<p>
These four mode atoms are also declared as prefix operators by the Logtalk compiler. This makes it possible to include type information for each argument like in the example above. Some of the possible type values are: <code>event</code>, <code>object</code>, <code>category</code>, <code>protocol</code>, <code>callable</code>, <code>term</code>, <code>nonvar</code>, <code>var</code>, <code>atomic</code>, <code>atom</code>, <code>number</code>, <code>integer</code>, <code>float</code>, <code>compound</code>, and <code>list</code>. The first four are Logtalk specific. The remaining are common Prolog types. We can also use our own types that can be either atoms or ground compound terms.
</p>
<p>
The second argument documents the number of proofs (not necessarily distinct solutions) for the specified mode. Note that different modes for the same predicate often have different determinism. The possible values are:
</p>
<dl>
	<dt><code>zero</code></dt>
		<dd>Predicate always fails.</dd>
	<dt><code>one</code></dt>
		<dd>Predicate always succeeds once.</dd>
	<dt><code>zero_or_one</code></dt>
		<dd>Predicate either fails or succeeds.</dd>
	<dt><code>zero_or_more</code></dt>
		<dd>Predicate has zero or more proofs.</dd>
	<dt><code>one_or_more</code></dt>
		<dd>Predicate has one or more proofs.</dd>
	<dt><code>error</code></dt>
		<dd>Predicate will throw an error (see below).</dd>
</dl>
<p>
Mode declarations can also be used to document that some call modes will throw an error. For instance, regarding the <code>arg/3</code> ISO Prolog built-in predicate, we may write:
</p>
<pre>:- mode(arg(-, -, +), error).</pre> 
<p>
Note that most predicates have more than one valid mode implying several mode directives. For example, to document the possible use modes of the <code>atom_concat/3</code> ISO built-in predicate we would write:
</p>
<pre>:- mode(atom_concat(?atom, ?atom, +atom), one_or_more).
:- mode(atom_concat(+atom, +atom, -atom), zero_or_one).</pre>
<p>
Some old Prolog compilers supported some sort of mode directives to improve performance. To the best of my knowledge, there is no modern Prolog compiler supporting these kind of directive. The current version of the Logtalk compiler just parses and than discards this directive (however, see the description on <a title="Consult user manual" href="threads.html#threads_synchronized_predicates">synchronized predicates</a> on the <a title="Consult user manual" href="threads.html">multi-threading programming</a> section). Nevertheless, the use of mode directives is a good starting point for documenting your predicates.
</p>

<h3 id="predicates_meta">Meta-predicate directive</h3>

<p>
Some predicates may have arguments that will be called as goals or closures that will be used for constructing a call. To ensure that these calls and closures will be executed in the correct scope (i.e. in the calling context, not in the meta-predicate definition context) we need to use the <a title="Consult reference manual" href="../refman/directives/meta_predicate_1.html"><code>meta_predicate/1</code></a> directive. For example:
</p>
<pre>:- meta_predicate(findall(*, 0, *)).</pre>
<p>
The meta-predicate mode arguments in this directive have the following meaning:
</p>
<dl>
	<dt><code>0</code></dt>
		<dd>Meta-argument that will be called as a goal.</dd>
	<dt><code>N</code></dt>
		<dd>Meta-argument that will be a closure used to construct a call by appending <code>N</code> arguments at the end. The value of <code>N</code> must be a non-negative integer.</dd>
	<dt><code>::</code></dt>
		<dd>Argument that is context-aware but that will not be called as a goal.</dd>
	<dt><code>^</code></dt>
		<dd>Goal that may be existentially quantified (<code>Vars^Goal</code>).</dd>
	<dt><code>*</code></dt>
		<dd>Normal argument.</dd>
</dl>
<p>
The following meta-predicate mode arguments are for use only when writing backend Prolog adapter files to deal with proprietary built-in meta-predicates and meta-directives:
</p>
<dl>
	<dt><code>/</code></dt>
		<dd>Predicate indicator (<code>Functor/Arity</code>), list of predicate indicators, or conjunction of predicate indicators.</dd>
	<dt><code>[0]</code></dt>
		<dd>List of goals.</dd>
	<dt><code>[/]</code></dt>
		<dd>List of predicate indicators.</dd>
</dl>
<p>
To the best of my knowledge, the use of non-negative integers to specify closures has first introduced on Quintus Prolog for providing information for predicate cross-reference tools.
</p>
<p>
As each Logtalk entity is independently compiled, this directive must be included in every object or category that contains a definition for the described meta-predicate, even if the meta-predicate declaration is inherited from another entity, to ensure proper compilation of meta-arguments.
</p>

<h3 id="predicates_discontiguous">Discontiguous directive</h3>

<p>
The clause of an object (or category) predicate may not be contiguous. In that case, we must declare the predicate discontiguous by using the <a title="Consult reference manual" href="../refman/directives/discontiguous_1.html"><code>discontiguous/1</code></a> directive:
</p>
<pre>:- discontiguous(foo/1).</pre>
<p>
This is a directive that we should avoid using: it makes your code harder to read and it is not supported by some Prolog compilers.
</p>
<p>
As each Logtalk entity is compiled independently from other entities, this directive must be included in every object or category that contains a definition for the described predicate (even if the predicate declaration is inherited from other entity).
</p>

<h3 id="predicates_dynamic">Dynamic directive</h3>

<p>
An object predicate can be static or dynamic. By default, all object predicates are static. To declare a dynamic predicate we use the <a title="Consult reference manual" href="../refman/directives/dynamic_1.html"><code>dynamic/1</code></a> directive:
</p>
<pre>:- dynamic(foo/1).</pre>
<p>
This directive may also be used to declare dynamic grammar rule non-terminals. As each Logtalk entity is compiled independently from other entities, this directive must be included in every object that contains a definition for the described predicate (even if the predicate declaration is inherited from other object or imported from a category). If we omit the dynamic declaration then the predicate definition will be compiled static. In the case of dynamic objects, static predicates cannot be redefined using the database built-in methods (despite being internally compiled to dynamic code).
</p>
<p>
Note that static objects may declare and define dynamic predicates.
</p>

<h3 id="predicates_op">Operator directive</h3>

<p>
An object (or category) predicate can be declared as an operator using the familiar <a title="Consult reference manual" href="../refman/directives/op_3.html"><code>op/3</code></a> directive:
</p>
<pre>:- op(Priority, Specifier, Operator).</pre>
<p>
Operators are local to the object (or category) where they are declared. This means that, if you declare a public predicate as an operator, you cannot use operator notation when sending to an object (where the predicate is visible) the respective message (as this would imply visibility of the operator declaration in the context of the <em>sender</em> of the message). If you want to declare global operators and, at the same time, use them inside an entity, just write the corresponding directives at the top of your source file, before the entity opening directive.
</p>
<p>
When the same operators are used on several entities within the same source file, the corresponding directives must appear before any entity that uses them. However, this results in a global scope for the operators. If you prefer the operators to be local to the source file, just <em>undefine</em> them at the end of the file. For example:
</p>
<pre>:- op(400, xfx, results).  % before any entity that uses the operator

...

:- op(0, xfx, results).    % after all entities that used the operator</pre>

<h3 id="predicates_uses">Uses directive</h3>

<p>
When a predicate makes heavy use of predicates defined on other objects, its predicate clauses can be verbose due to all the necessary message sending goals. Consider the following example:
</p>
<pre>foo :-
    ...,
    findall(X, list::member(X, L), A),
    list::append(A, B, C),
    list::select(Y, C, R),
    ...</pre>
<p>
Logtalk provides a directive, <a title="Consult reference manual" href="../refman/directives/uses_2.html"><code>uses/2</code></a>, which allows us to simplify the code above. The usage template for this directive is:
</p>
<pre>:- uses(Object, [Functor1/Arity1, Functor2/Arity2, ...]).</pre>
<p>
Rewriting the code above using this directive results in a simplified and more readable predicate definition:
</p>
<pre>:- uses(list, [
    append/3, member/2, select/3
]).

foo :-
    ...,
    findall(X, member(X, L), A),
    append(A, B, C),
    select(Y, C, R),
    ...</pre>
<p>
Logtalk also supports an extended version of this directive that allows the declaration of predicate alias using the notation <code>Predicate as Alias</code> (or the alternative notation <code>Predicate::Alias</code>). For example:
</p>
<pre>:- uses(btrees, [new/1 as new_btree/1]).
:- uses(queues, [new/1 as new_queue/1]).</pre>
<p>
You may use this extended version for solving conflicts between predicates declared on several <code>uses/2</code> directives or just for giving new names to the predicates that will be more meaningful on their using context.
</p>
<p>
The <code>uses/2</code> directive allows simpler predicate definitions as long as there are no conflicts between the predicates declared in the directive and the predicates defined in the object (or category) containing the directive. A predicate (or its alias if defined) cannot be listed in more than one <code>uses/2</code> directive. In addition, a <code>uses/2</code> directive cannot list a predicate (or its alias if defined) which is defined in the object (or category) containing the directive. Any conflicts are reported by Logtalk as compilation errors.
</p>

<h3 id="predicates_alias">Alias directive</h3>

<p>
Logtalk allows the definition of an alternative name for an inherited or imported predicate (or for an inherited or imported grammar rule non-terminal) through the use of the <a title="Consult reference manual" href="../refman/directives/alias_2.html"><code>alias/2</code></a> directive:
</p>
<pre>:- alias(Entity, [Predicate1 as Alias1, Predicate2 as Alias2, ...]).</pre>
<p>
This directive can be used in objects, protocols, or categories. The first argument, <code>Entity</code>, must be an entity referenced in the opening directive of the entity containing the <code>alias/2</code> directive. It can be an implemented protocol, an imported category, an extended prototype, an instantiated class, or a specialized class. The second and third arguments are predicate indicators (or grammar rule non-terminal indicators).
</p>
<p>
A common use for the <code>alias/2</code> directive is to give an alternative name to an inherited predicate in order to improve readability. For example:
</p>
<pre>:- object(square,
    extends(rectangle)).

    :- alias(rectangle, [width/1 as side/1]).

    ...

:- end_object.</pre>
<p>
The directive allows both <code>width/1</code> and <code>side/1</code> to be used as messages to the object <code>square</code>. Thus, using this directive, there is no need to explicitly declare and define a "new" <code>side/1</code> predicate. Note that the <code>alias/2</code> directive does not rename a predicate, only provides an alternative, additional name; the original name continues to be available (although it may be masked due to the default inheritance conflict mechanism).
</p>
<p>
Another common use for this directive is to solve conflicts when two inherited predicates have the same functor and arity. We may want to call the predicate which is masked out by the Logtalk lookup algorithm (see the <a href="inheritance.html">Inheritance</a> section) or we may need to call both predicates. This is simply accomplished by using the <code>alias/2</code> directive to give alternative names to masked out or conflicting predicates. Consider the following example:
</p>
<pre>:- object(my_data_structure,
    extends(list, set)).

    :- alias(list, [member/2 as list_member/2]).
    :- alias(set,  [member/2 as set_member/2]).

    ...

:- end_object.</pre>
<p>
Assuming that both <code>list</code> and <code>set</code> objects define a <code>member/2</code> predicate, without the <code>alias/2</code> directives, only the definition of <code>member/2</code> predicate in the object <code>list</code> would be visible on the object <code>my_data_structure</code>, as a result of the application of the Logtalk predicate lookup algorithm. By using the <code>alias/2</code> directives, all the following messages would be valid (assuming a public scope for the predicates):
</p>
<pre>| ?- my_data_structure::list_member(X, L).    % uses list member/2

| ?- my_data_structure::set_member(X, L).     % uses set member/2

| ?- my_data_structure::member(X, L).         % uses list member/2</pre>
<p>
When used this way, the <code>alias/2</code> directive provides functionality similar to programming constructs of other object-oriented languages which support multi-inheritance (the most notable example probably being the renaming of inherited features in Eiffel).
</p>
<p>
Note that the <code>alias/2</code> directive never hides a predicate which is visible on the entity containing the directive as a result of the Logtalk lookup algorithm. However, it may be used to make visible a predicate which otherwise would be masked by another predicate, as illustrated in the above example.
</p>
<p>
The <code>alias/2</code> directive may also be used to give access to an inherited predicate, which otherwise would be masked by another inherited predicate, while keeping the original name as follows:
</p>
<pre>:- object(my_data_structure,
    extends(list, set)).

    :- alias(list, [member/2 as list_member/2]).
    :- alias(set,  [member/2 as set_member/2]).

    member(X, L) :-
        ::set_member(X, L).

    ...

:- end_object.</pre>
<p>
Thus, when sending the message <code>member/2</code> to <code>my_data_structure</code>, the predicate definition in <code>set</code> will be used instead of the one contained in <code>list</code>.
</p>

<h3 id="predicates_info">Documenting directive</h3>

<p>
A predicate can be documented with arbitrary user-defined information by using the <a title="Consult reference manual" href="../refman/directives/info_2.html"><code>info/2</code></a> directive:
</p>
<pre>:- info(Functor/Arity, List).</pre>
<p>
The second argument is a list of <code>Key is Value</code> terms. See the <a href="documenting.html">Documenting Logtalk programs</a> section for details.
</p>

<h3 id="predicates_multifile">Multifile directive</h3>

<p>
A predicate can be declared <em>multifile</em> by using the <a title="Consult reference manual" href="../refman/directives/multifile_1.html"><code>multifile/1</code></a> directive:
</p>
<pre>:- multifile(Functor/Arity).</pre>
<p>
This allows clauses for a predicate to be defined in several objects and/or categories. This is a directive that should be used with care. Support for this directive have been added to Logtalk primarily to support migration of Prolog module code. Spreading clauses for a predicate among several Logtalk entities can be handy in some cases but can also make your code difficult to understand. Logtalk precludes using a multifile predicate for breaking object encapsulation by checking that the object (or category) declaring the predicate (using a <code>public/1</code> scope directive) defines it also as multifile. This entity is said to contain the <em>primary declaration</em> for the multifile predicate. In addition, note that the <code>multifile/1</code> directive is mandatory when defining multifile predicates.
</p>
<p>
Consider the following simple example:
</p>
<pre>
:- object(main).

    :- public(a/1).
    :- multifile(a/1).
    a(1).

:- end_object.
</pre>
<p>
After compiling and loading the <code>main</code> object, we can define other objects (or categories) that contribute with clauses for the multifile predicate. For example:
</p>
<pre>
:- object(other).

    :- multifile(main::a/1).
    main::a(2).
    main::a(X) :-
        b(X).

    b(3).
    b(4).

:- end_object.
</pre>
<p>
After compiling and loading the above objects, you can use queries such as:
</p>
<pre>
| ?- main::a(X).

X = 1 ;
X = 2 ;
X = 3 ;
X = 4
yes
</pre>
<p>
Entities containing primary multifile predicate declarations must always be compiled before entities defining clauses for those multifile predicates. The Logtalk compiler will print a warning if the <code>multifile/1</code> directive is missing. Multifile predicates may also be declared dynamic using the same <code>Entity::Functor/Arity</code> notation (multifile predicates are static by default).
</p>
<p>
When a clause of a multifile predicate is a rule, its body is compiled within the context of the object or category defining the clause. This allows clauses for multifile predicates to call local object or category predicates. But the values of the <em>sender</em>, <em>this</em>, and <em>self</em> in the implicit execution context are passed from the clause head to the clause body. A call to the <code>parameter/2</code> execution context methods retrieves parameters of the entity defining the clause, not from the entity for which the clause is defined. The parameters of the entity for which the clause is defined can be accessed by simple unification at the clause head.
</p>

<h3 id="predicates_coinductive">Coinductive directive</h3>

<p>
A predicate can be declared <em>coinductive</em> by using the <a title="Consult reference manual" href="../refman/directives/coinductive_1.html"><code>coinductive/1</code></a> directive. For example:
</p>
<pre>:- coinductive(comember/2).</pre>
<p>
Logtalk support for coinductive predicates is experimental and requires a back-end Prolog compiler with minimal support for cyclic terms.
</p>

<h2 id="predicates_defining">Defining predicates</h2>

<h3 id="predicates_objects">Object predicates</h3>

<p>
We define object predicates as we have always defined Prolog predicates, the only difference be that we have four more control structures (the three message sending operators plus the external call operator) to play with. For example, if we wish to define an object containing common utility list predicates like <code>append/2</code> or <code>member/2</code> we could write something like:
</p>
<pre>:- object(list).

    :- public(append/3).
    :- public(member/2).

    append([], L, L).
    append([H| T], L, [H| T2]) :-
        append(T, L, T2).

    member(H, [H| _]).
    member(H, [_| T]) :-
        member(H, T).

:- end_object.</pre>
<p>
Note that, abstracting from the opening and closing object directives and the scope directives, what we have written is plain Prolog.  Calls in a predicate definition body default to the local predicates, unless we use the message sending operators or the external call operator. This enables easy conversion from Prolog code to Logtalk objects: we just need to add the necessary encapsulation and scope directives to the old code.
</p>

<h3 id="predicates_categories">Category predicates</h3>

<p>
Because a category can be imported by several different objects, dynamic private predicates must be called either in the context of <em>self</em>, using the <em>message to self</em> control structure, <a title="Consult reference manual" href="../refman/control/send_to_self_1.html"><code>::/1</code></a>, or in the context of <em>this</em> (i.e. in the context of the object importing the category). For example, if we want to define a category implementing variables using destructive assignment where the variable values are stored in <em>self</em> we could write:
</p>
<pre>:- category(variable).

    :- public(get/2).
    :- public(set/2).

    :- private(value_/2).
    :- dynamic(value_/2).

    get(Var, Value) :-
        ::value_(Var, Value).

    set(Var, Value) :-
        ::retractall(value_(Var, _)), 
        ::asserta(value_(Var, Value).

:- end_category.</pre>
<p>
In this case, the <code>get/2</code> and <code>set/2</code> predicates will always access/update the correct definition, contained in the object receiving the messages. The alternative, storing the variable values in <em>this</em>, such that  each object importing the category will have its own definition for the <code>value_/2</code> private predicate is simple: just omit the use of the <code>::/1</code> control construct in the code above.
</p>
<p>
A category may only contain clauses for static predicates. Nevertheless, as the example above illustrates, there are no restrictions in declaring and calling dynamic predicates from inside a category.
</p>

<h3 id="predicates_metadef">Meta-predicates</h3>

<p>
Meta-predicates may be defined inside objects (and categories) as any other predicate. A meta-predicate is declared using the <code>meta_predicate/1</code> directive as described earlier on this section. When defining a meta-predicate, the arguments in the clause heads corresponding to the meta-arguments must be variables. All meta-arguments are called in the context of the entity calling the meta-predicate.
</p>
<p>
Some meta-predicates have meta-arguments which are not goals but closures. Logtalk supports the definition of meta-predicates that are called with closures instead of goals as long as the definition uses the Logtalk built-in predicate <a title="Consult reference manual" href="../refman/methods/call_N.html"><code>call/N</code></a> to call the closure with the additional arguments. For example:
</p>
<pre>:- public(all_true/2).
:- meta_predicate(all_true(1, *)).

all_true(_, []).
all_true(Closure, [Arg| Args]) :-
    call(Closure, Arg),
    all_true(Closure, Args).</pre>
<p>
Note that in this case the meta-predicate directive specifies that the closure will be extended with exactly one extra argument.
</p>
<p>
When calling a meta-predicate, a closure can correspond to a user-defined predicate, a built-in predicate, a lambda expression, or a control construct.
</p>

<h3 id="predicates_lambdas">Lambda expressions</h3>
<p>
The use of <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda expressions</a> as meta-predicate goal and closure arguments often saves writing auxiliary predicates for the sole purpose of calling the meta-predicates. A simple example of a lambda expression is:
</p>
<pre>| ?- meta::map([X,Y]&gt;&gt;(Y is 2*X), [1,2,3], Ys).
Ys = [2,4,6]
yes</pre>
<p>
In this example, a lambda expression, <code>[X,Y]&gt;&gt;(Y is 2*X)</code>, is used as an argument to the <code>map/3</code> list mapping predicate, defined in the library object <code>meta</code>, in order to double the elements of a list of integers. Using a lambda expression avoids writing an auxiliary predicate for the sole purpose of doubling the list elements. The lambda parameters are represented by the list <code>[X,Y]</code>, which is connected to the lambda goal, <code>(Y is 2*X)</code>, by the <code>(&gt;&gt;)/2</code> operator.
</p>
<p>
Currying is supported. I.e. it is possible to write a lambda expression whose goal is another lambda expression. The above example can be rewritten as:
</p>
<pre>| ?- meta::map([X]&gt;&gt;([Y]&gt;&gt;(Y is 2*X)), [1,2,3], Ys).
Ys = [2,4,6]
yes</pre>
<p>
Lambda expressions may also contain lambda free variables. I.e. variables that are global to the lambda expression. For example, using GNU Prolog as the back-end compiler, we can write:
</p>
<pre>| ?- meta::map({Z}/[X,Y]&gt;&gt;(Z#=X+Y), [1,2,3], Zs).
Z = _#22(3..268435455)
Zs = [_#3(2..268435454),_#66(1..268435453),_#110(0..268435452)]
yes</pre>
<p>
The ISO Prolog construct <code>{}/1</code> for representing the lambda free variables as this representation is often associated with set representation. Note that the order of the free variables is of no consequence (on the other hand, a list is used for the lambda parameters as their order does matter).
</p>
<p>
Both lambda free variables and lambda parameters can be any Prolog term. Consider the following example by Markus Triska:
</p>
<pre>| ?- meta::map([A-B,B-A]&gt;&gt;true, [1-a,2-b,3-c], Zs).
Zs = [a-1,b-2,c-3]
yes</pre>
<p>
Lambda expressions can be used, as expected, in non-deterministic queries as in the following example using SWI-Prolog as the back-end compiler and Markus Triska's CLP(FD) library:
</p>
<pre>| ?- meta::map({Z}/[X,Y]&gt;&gt;(clpfd:(Z#=X+Y)), Xs, Ys).
Xs = [],
Ys = [] ;
Xs = [_G1369],
Ys = [_G1378],
_G1369+_G1378#=Z ;
Xs = [_G1579, _G1582],
Ys = [_G1591, _G1594],
_G1582+_G1594#=Z,
_G1579+_G1591#=Z ;
Xs = [_G1789, _G1792, _G1795],
Ys = [_G1804, _G1807, _G1810],
_G1795+_G1810#=Z,
_G1792+_G1807#=Z,
_G1789+_G1804#=Z ;
...</pre>
<p>
As illustrated by the above examples, lambda expression syntax reuses the ISO Prolog construct <code>{}/1</code> and the standard operators <code>(/)/2</code> and <code>(&gt;&gt;)/2</code>, thus avoiding defining new operators, which is always tricky for a portable system such as Logtalk. The operator <code>(&gt;&gt;)/2</code> was chosen as it suggests an arrow, similar to the syntax used in other languages such as OCaml and Haskell to connect lambda parameters with lambda functions. This syntax was also chosen in order to simplify parsing, error checking, and compilation of lambda expressions. The full specification of the lambda expression syntax can be found in the <a href="http://logtalk.org/manuals/refman/grammar.html#grammar_lambdas">reference manual</a>.
</p>
<p>
The compiler checks whenever possible that all variables in a lambda expression are either classified as free variables or as lambda parameters. The use of non-classified variables in a lambda expression should be regarded as a programming error. Unfortunately, the dynamic features of the language and lack of sufficient information at compile time may prevent the compiler of checking all uses of lambda expressions. The compiler also checks if a variable is classified as both a free variable and a lambda parameter. An optimizing meta-predicate and lambda expression compiler, based on the term-expansion mechanism, is provided for practical performance.
</p>

<h3 id="predicates_dcgs">Definite clause grammar rules</h3>

<p>
Definite clause grammar rules provide a convenient notation to represent the rewrite rules common of most grammars in Prolog. In Logtalk, definite clause grammar rules can be encapsulated in objects and categories. Currently, the ISO/IEC WG17 group is working on a draft specification for a definite clause grammars Prolog standard. Therefore, in the mean time, Logtalk follows the common practice of Prolog compilers supporting definite clause grammars, extending it to support calling grammar rules contained in categories and objects. A common example of a definite clause grammar is the definition of a set of rules for parsing simple arithmetic expressions:
</p>
<pre>:- object(calculator).

    :- public(parse/2).

    parse(Expression, Value) :-
        phrase(expr(Value), Expression).

    expr(Z) --&gt; term(X), "+", expr(Y), {Z is X + Y}.
    expr(Z) --&gt; term(X), "-", expr(Y), {Z is X - Y}.
    expr(X) --&gt; term(X).

    term(Z) --&gt; number(X), "*", term(Y), {Z is X * Y}.
    term(Z) --&gt; number(X), "/", term(Y), {Z is X / Y}.
    term(Z) --&gt; number(Z).

    number(C) --&gt; "+", number(C).
    number(C) --&gt; "-", number(X), {C is -X}.
    number(X) --&gt; [C], {0'0 =&lt; C, C =&lt; 0'9, X is C - 0'0}.

:- end_object. </pre>
<p>
The predicate <a title="Consult reference manual" href="../refman/methods/phrase_2.html"><code>phrase/2</code></a> called in the definition of predicate <code>parse/2</code> above is a Logtalk built-in method, similar to the predicate with the same name found on most Prolog compilers that support definite clause grammars. After compiling and loading this object, we can test the grammar rules with calls such as the following one:
</p>
<pre>| ?- calculator::parse("1+2-3*4", Result).

Result = -9
yes</pre>
<p>
In most cases, the predicates resulting from the translation of the grammar rules to regular clauses are not declared. Instead, these predicates are usually called by using the built-in methods <a title="Consult reference manual" href="../refman/methods/phrase_2.html"><code>phrase/2</code></a> and <a title="Consult reference manual" href="../refman/methods/phrase_3.html"><code>phrase/3</code></a> as shown in the example above. When we want to use the built-in methods <code>phrase/2</code> and <code>phrase/3</code>, the non-terminal used as first argument must be within the scope of the <em>sender</em>. For the above example, assuming that we want the predicate corresponding to the <code>expr//1</code> non-terminal to be public, the corresponding scope directive would be:
</p>
<pre>:- public(expr//1). </pre>
<p>
The <code>//</code> infix operator used above tells the Logtalk compiler that the scope directive refers to a grammar rule non-terminal, not to a predicate. The idea is that the predicate corresponding to the translation of the <code>expr//1</code> non-terminal will have a number of arguments equal to one plus the number of additional arguments necessary for processing the subjacent lists of tokens.
</p>
<p>
In the body of a grammar rule, we can call rules that are inherited from ancestor objects, imported from categories, or contained in other objects. This is accomplished by using non-terminals as messages. Using a non-terminal as a message to <em>self</em> allows us to call grammar rules in categories and ancestor objects. To call grammar rules encapsulated in other objects, we use a non-terminal as a message to those objects. Consider the following example, containing grammar rules for parsing natural language sentences:
</p>
<pre>:- object(sentence,
    imports(determiners, nouns, verbs)).

    :- public(parse/2).

    parse(List, true) :-
        phrase(sentence, List).
    parse(_, false).

    sentence --&gt; noun_phrase, verb_phrase.

    noun_phrase --&gt; ::determiner, ::noun.
    noun_phrase --&gt; ::noun.

    verb_phrase --&gt; ::verb.
    verb_phrase --&gt; ::verb, noun_phrase.

:- end_object.</pre>
<p>
The categories imported by the object would contain the necessary grammar rules for parsing determiners, nouns, and verbs. For example:
</p>
<pre>:- category(determiners).

    :- private(determiner//0).

    determiner --&gt; [the].
    determiner --&gt; [a].

:- end_category.</pre>
<p>
Along with the message sending operators (<code>::/1</code>, <code>::/2</code>, and <code>^^/1</code>), we may also use other control constructs such as <code>\+/1</code>, <code>!/0</code>, <code>;/2</code>, <code>-&gt;/2</code>, and <code>{}/1</code> in the body of a grammar. In addition, grammar rules may contain meta-calls (a variable taking the place of a non-terminal), which are translated to calls of the built-in method <code>phrase/3</code>. 
</p>
<p>
You may have noticed that Logtalk defines <code>{}/1</code> as a control construct for bypassing the compiler when compiling a clause body goal. As exemplified above, this is the same control construct that is used in grammar rules for bypassing the expansion of rule body goals when a rule is converted into a clause. Both control constructs can be combined in order to call a goal from a grammar rule body, while bypassing at the same time the Logtalk compiler. Consider the following example:
</p>
<pre>bar :-
    write('bar predicate called'), nl.


:- object(bypass).

    :- public(foo//0).

    foo --&gt; {{bar}}.

:- end_object.</pre>
<p>
After compiling and loading this code, we may try the following query:
</p>
<pre>| ?- logtalk &lt;&lt; phrase(bypass::foo, _, _).

bar predicate called
yes</pre>
<p>
This is the expected result as the expansion of the grammar rule into a clause leaves the <code>{bar}</code> goal untouched, which, in turn, is converted into the goal <code>bar</code> when the clause is compiled.
</p>
<p>
A grammar rule non-terminal may be declared as dynamic or discontiguous, as any object predicate, using the same <code><em>Functor//Arity</em></code> notation illustrated above for the scope directives. In addition, grammar rule non-terminals can be documented using the <a title="Consult reference manual" href="../refman/directives/info_2.html"><code>info/2</code></a> directive, as in the following example:
</p>
<pre>:- public(sentence//0).

:- info(sentence//0, [
    comment is 'Rewrites a sentence into a noun phrase and a verb phrase.']).</pre>

<h2 id="predicates_methods">Built-in object predicates (methods)</h2>

<p>
Logtalk defines a set of built-in object predicates or methods to access message execution context, to find sets of solutions, to inspect objects, for database handling, for term and goal expansion, and for printing messages. Similar to Prolog built-in predicates, these built-in methods should not be redefined.
</p>

<h3 id="predicates_context">Execution context methods</h3>

<p>
Logtalk defines four built-in private methods to access an object execution context. These methods (with the possible exception of <code>parameter/2</code>) are translated to a single unification performed at compile time with a clause head context argument. Therefore, they can be freely used without worrying about performance penalties. When called from inside a category, these methods refer to the execution context of the object importing the category. These methods cannot be used as messages to objects.
</p>
<p>
To find the object that received the message under execution we may use the <a title="Consult reference manual" href="../refman/methods/self_1.html"><code>self/1</code></a> method. We may also retrieve the object that has sent the message under execution using the <a title="Consult reference manual" href="../refman/methods/sender_1.html"><code>sender/1</code></a> method.
</p>
<p>
The method <a title="Consult reference manual" href="../refman/methods/this_1.html"><code>this/1</code></a> enables us to retrieve the name of the object for which the predicate clause whose body is being executed is defined instead of using the name directly. This helps to avoid breaking the code if we decide to change the object name and forget to change the name references. This method may also be used from within a category. In this case, the method returns the object importing the category on whose behalf the predicate clause is being executed.
</p>
<p>
Here is a short example including calls to these three object execution context methods:
</p>
<pre>:- object(test).

    :- public(test/0).

    test :-
        this(This), 
        write('Executing  a predicate definition contained in '), writeq(This), nl,
        self(Self),
        write('to answer a message received by '), writeq(Self), nl,
        sender(Sender),
        write('that was sent by '), writeq(Sender), nl, nl.

:- end_object.


:- object(descendant,
    extends(test)).

:- end_object.</pre>
<p>
After compiling and loading these two objects, we can try the following goal:
</p>
<pre>| ?- descendant::test.

Executing  a predicate definition contained in test
to answer a message received by descendant
that was sent by user
yes</pre>
<p>
Note that the goals <code>self(Self)</code>, <code>sender(Sender)</code>, and <code>this(This)</code>, being translated to unifications with the clause head context arguments at compile time, are effectively removed from the clause body. Therefore, a clause such as:
</p>
<pre>predicate(Arg) :-
    self(Self),
    atom(Arg),
    ... .</pre>
<p>
is compiled with the goal <code>atom(Arg)</code> as the first condition on the clause body. As such, the use of these context execution methods do not interfere with the optimizations that some Prolog compilers perform when the first clause body condition is a call to a built-in type-test predicate or a comparison operator. 
</p>
<p>
For parametric objects and categories, the method <a title="Consult reference manual" href="../refman/methods/parameter_2.html"><code>parameter/2</code></a> enables us to retrieve current parameter values (see the section on <a href="objects.html#parametric">parametric objects</a> for a detailed description). For example:
</p>
<pre>:- object(block(_Color)).

    :- public(test/0).

    test :-
        parameter(1, Color), 
        write('Color parameter value  is '), writeq(Color), nl.

:- end_object.</pre>
<p>
After compiling and loading these two objects, we can try the following goal:
</p>
<pre>| ?- block(blue)::test.

Color parameter value is blue
yes</pre>
<p>
The method <code>parameter/2</code> is only translated to a compile time unification for parametric objects. When the method is used in a parametric category, its call is translated to a call to the built-in Prolog predicate <code>arg/3</code>.
</p>

<h3 id="predicates_database">Database methods</h3>

<p>
Logtalk provides a set of built-in methods for object database handling similar to the usual database Prolog predicates: <a title="Consult reference manual" href="../refman/methods/abolish_1.html"><code>abolish/1</code></a>, <a title="Consult reference manual" href="../refman/methods/asserta_1.html"><code>asserta/1</code></a>, <a title="Consult reference manual" href="../refman/methods/assertz_1.html"><code>assertz/1</code></a>, <a title="Consult reference manual" href="../refman/methods/clause_2.html"><code>clause/2</code></a>, <a title="Consult reference manual" href="../refman/methods/retract_1.html"><code>retract/1</code></a>, and <a title="Consult reference manual" href="../refman/methods/retractall_1.html"><code>retractall/1</code></a>. These methods always operate on the database of the object receiving the corresponding message.
</p>
<p>
When working with dynamic grammar rule non-terminals, you may use the built-in method <a title="Consult reference manual" href="../refman/methods/expand_term_2.html"><code>expand_term/2</code></a> convert a grammar rule into a clause that can than be used with the database methods.
</p>

<h3 id="predicates_metacalls">Meta-call methods</h3>

<p>
Logtalk supports the generalized <a title="Consult reference manual" href="../refman/methods/call_N.html"><code>call/1-N</code></a> meta-predicate. This built-in private meta-predicate must be used in the implementation of meta-predicates which work with closures instead of goals. In addition, Logtalk supports the built-in private meta-predicates <a title="Consult reference manual" href="../refman/methods/ignore_1.html"><code>ignore/1</code></a>, <a title="Consult reference manual" href="../refman/methods/once_1.html"><code>once/1</code></a>, and <a title="Consult reference manual" href="../refman/methods/not_1.html"><code>\+/1</code></a>. These methods cannot be used as messages to objects.
</p>

<h3 id="predicates_solutions">All solutions methods</h3>

<p>
The usual all solutions meta-predicates are built-in private methods in Logtalk: <a title="Consult reference manual" href="../refman/methods/bagof_3.html"><code>bagof/3</code></a>, <a title="Consult reference manual" href="../refman/methods/findall_3.html"><code>findall/3</code></a>, <a title="Consult reference manual" href="../refman/methods/findall_4.html"><code>findall/4</code></a>, and <a title="Consult reference manual" href="../refman/methods/setof_3.html"><code>setof/3</code></a>. There is also a <a title="Consult reference manual" href="../refman/methods/forall_2.html"><code>forall/2</code></a> method that implements generate and test loops. These methods cannot be used as messages to objects.
</p>

<h3 id="predicates_reflection">Reflection methods</h3>

<p>
Logtalk provides a comprehensive set of built-in predicates and built-in methods for querying about entities and predicates. Some of information, however, requires that the source files are compiled with the <code>source_data</code> flag turned on.
</p>
<p>
The reflection API supports two different views on entities and their contents, which we may call the <em>transparent box view</em> and the <em>black box view</em>. In the transparent box view, we look into an entity disregarding how it will be used and returning all information available on it, including predicate declarations and predicate definitions. This view is supported by the entity property built-in predicates. In the black box view, we look into an entity from an usage point-of-view using built-in methods for inspecting object operators and predicates that are within scope from where we are making the call: <a title="Consult reference manual" href="../refman/methods/current_op_3.html"><code>current_op/3</code></a>, which returns operator specifications, <a title="Consult reference manual" href="../refman/methods/predicate_property_2.html"><code>predicate_property/2</code></a>, which returns predicate properties, and <a title="Consult reference manual" href="../refman/methods/current_predicate_1.html"><code>current_predicate/1</code></a>, which enables us to query about predicate definitions. See below for a more detailed description of these methods.
</p>

<h3 id="predicates_parsing">Definite clause grammar parsing methods and non-terminals</h3>

<p>
Logtalk supports two definite clause grammar parsing built-in private methods, <a title="Consult reference manual" href="../refman/methods/phrase_2.html"><code>phrase/2</code></a> and <a title="Consult reference manual" href="../refman/methods/phrase_3.html"><code>phrase/3</code></a>, with definitions similar to the predicates with the same name found on most Prolog compilers that support definite clause grammars. These methods cannot be used as messages to objects.
</p>
<p>
Logtalk also supports <a title="Consult reference manual" href="../refman/methods/phrase_1.html"><code>phrase//1</code></a> and <a title="Consult reference manual" href="../refman/methods/call_1.html"><code>call//1-N</code></a> built-in non-terminals. The <code>call//1-N</code> non-terminals takes a closure (which can be a lambda expression) plus zero or more additional arguments and are processed by appending the input list of tokens and the list of remaining tokens to the arguments.
</p>

<h3 id="predicates_expanding">Term and goal expansion methods</h3>

<p>
Logtalk supports a <a title="Consult reference manual" href="../refman/methods/expand_term_2.html"><code>expand_term/2</code></a> built-in method for expanding a term into a list of terms. This method is mainly used to translate grammar rules into Prolog clauses. It can be customized, e.g. for bypassing the default Logtalk grammar rule translator, by defining clauses for the predicate <a title="Consult reference manual" href="../refman/methods/term_expansion_2.html"><code>term_expansion/2</code></a>.
</p>
<p>
Logtalk also supports a <a title="Consult reference manual" href="../refman/methods/expand_goal_2.html"><code>expand_goal/2</code></a> built-in method for expanding a goal. This method can be customized by defining clauses for the predicate <a title="Consult reference manual" href="../refman/methods/goal_expansion_2.html"><code>goal_expansion/2</code></a>.
</p>
<p>
Term and goal expansion may be performed either by calling the <code>expand_term/2</code> and <code>expand_goal/2</code> built-in methods explicitly or by using <em><a class="glossary" title="Go to glossary definition" href="../glossary.html#hook">hook objects</a></em>. To compile a source file using a hook object for expanding its terms, you can use the <a title="Consult reference manual" href="programming.html#programming_flags"><code>hook/1</code></a> compiler flag in the second argument of the <a title="Consult reference manual" href="../refman/predicates/logtalk_compile_2.html"><code>logtalk_compile/2</code></a> or <a title="Consult reference manual" href="../refman/predicates/logtalk_load_2.html"><code>logtalk_load/2</code></a> built-in predicates. You can also use the <a title="Consult reference manual" href="../refman/directives/set_logtalk_flag_2.html"><code>set_logtalk_flag/2</code></a> directive in the source file itself. Clauses for the <code>term_expansion/2</code> and <code>goal_expansion/2</code> predicates defined within an object or a category are never used in the compilation of the object or the category itself, however. In order to use clauses for the <code>term_expansion/2</code> and <code>goal_expansion/2</code> predicates defined in plain Prolog, you will need to explicitly specify the pseudo-object <code>user</code> as the hook object when compiling source files. When using backend Prolog compilers that support a module system, it can also be specified a module containing clauses for the expanding predicates as long as the module name doesn't coincide with an object name. 
</p>
<p>
When compiling a source file, the compiler will first try the source file specific hook object, if defined. If that fails, it tries the default hook object, if defined. If that also fails, the compiler tries the Prolog dialect specific expansion predicate definitions if defined in the adapter file.
</p>
<p>
Logtalk provides a <a title="Consult reference manual" href="../refman/predicates/logtalk_load_context_2.html"><code>logtalk_load_context/2</code></a> built-in predicate that can be used to access the compilation/loading context when performing term-expansion or goal-expansion.
</p>

<h3 id="predicates_messages">Printing messages</h3>

<p>
Logtalk features a <em>structured message printing</em> mechanism. This feature gives the programmer full control of message printing, allowing it to filter, rewrite, or redirect any message. The origins of the mechanism for message printing that inspired the Logtalk implementation go back to Quintus Prolog, where it was implemented, apparently, by Dave Bowen (thanks to Richard O'Keefe for the historical bits). This mechanism can also be found currently on e.g. SICStus Prolog, SWI-Prolog, and YAP.
</p>
<p>
Why a mechanism for printing messages? Consider the different components in a Logtalk application development and execution. At the bottom level, you have the Logtalk compiler and runtime. The Logtalk compiler writes messages related to e.g. compiling and loading files, compiling entities, compilation warnings and errors. The Logtalk runtime many write banner messages and handles execution errors that may result in printing human-level messages. The development environment can be console-based or you may be using a GUI tool such as PDT. In the latter case, PDT needs to intercept the Logtalk compiler and runtime messages to do its magic and present the relevant information using its GUI. Then you have all the other components in a typical application. For example, your own libraries and third-party libraries. The libraries may want to print messages on its own, e.g banners, debugging information, or logging information. As you assemble all your application components, you want to have the final word on which messages are printed, where, an in what conditions.
</p>
<p>
The Logtalk message printing mechanism provides you with a set of predicates, defined in the <code>logtalk</code> built-in object, and some hook predicates. Two of the most important predicates are <a title="Consult reference manual" href="../refman/methods/print_message_3.html"><code>logtalk::print_message(Kind, Component, Term)</code></a>, which is used for printing a message, and <a title="Consult reference manual" href="../refman/methods/message_hook_4.html"><code>logtalk::message_hook(Term, Kind, Component, Tokens)</code></a>, a user-defined hook predicate used for intercepting messages. The <code>Kind</code> argument is used to represent the nature of the message being printed. It can be e.g. a logging message, a warning message or an error message, In Logtalk this argument can be either an atom, e.g. <code>error</code>, or a compound term, e.g. <code>comment(loading)</code>. Using a compound term allows easy partitioning of messages of the same kind in different groups. The following kinds of message are recognized by default:
</p>
<dl>
	<dt><code>banner</code></dt>
		<dd>banner messages (used e.g. when loading tools or main application components; can be suppressed by setting the <code>report</code> flag to <code>warnings</code> or <code>off</code>)</dd>
	<dt><code>help</code></dt>
		<dd>messages printed in reply for the user asking for help (mostly for helping port existing Prolog code)</dd>
	<dt><code>information</code> and <code>information(Group)</code></dt>
		<dd>messages printed usually in reply to a user request for information</dd>
	<dt><code>silent</code> and <code>silent(Group)</code></dt>
		<dd>not printed by default (but can be intercepted using the <code>message_hook/4</code> predicate)</dd>
	<dt><code>comment</code> and <code>comment(Group)</code></dt>
		<dd>useful but usually not essential messages (can be suppressed by setting the <code>report</code> flag to <code>warnings</code> or <code>off</code>)</dd>
	<dt><code>warning</code> and <code>warning(Group)</code></dt>
		<dd>warning messages (generated e.g. by the compiler; can be suppressed by turning off the <code>report</code> flag)</dd>
	<dt><code>error</code> and <code>error(Group)</code></dt>
		<dd>error messages (generated e.g. by the compiler)</dd>
</dl>
<p>
Note that you can define your own alternative message kind identifiers, for your own components, together with suitable definitions for their associated prefixes and output streams.
</p>
<p>
Messages are represented by atoms or compound terms, handy for machine-processing, and converted into a list of tokens, for human consumption. This conversion is performed using the non-terminal <a title="Consult reference manual" href="../refman/methods/message_tokens_2.html"><code>logtalk::message_tokens(Term, Component)</code></a>. A simple example is:
</p>
<pre>
:- multifile(logtalk::message_tokens//2).
:- dynamic(logtalk::message_tokens//2).

logtalk::message_tokens(loaded_settings_file(Path), core) --&gt;
    ['Loaded settings file found on directory ~w'-[Path], nl, nl].
</pre>
<p>
The <code>Component</code> argument is new in the Logtalk implementation and is useful to filter messages belonging to a specific component (e.g. the Logtalk compiler and runtime is identified by the atom <code>core</code>) and also to avoid conflicts when two different components define the same message term (e.g. <code>banner</code> seems to be popular).
</p>
<p>
The following tokens can be used when translating a message:
</p>
<dl>
	<dt><code>at_same_line</code></dt>
		<dd>Signals a following part to a multi-part message with no line break in between; this token is ignored when it's not the first in the list of tokens</dd>
	<dt><code>flush</code></dt>
		<dd>Flush the output stream (by calling the <code>flush_output/1</code> standard predicate)</dd>
	<dt><code>nl</code></dt>
		<dd>Change line in the output stream</dd>
	<dt><code>Format-Arguments</code></dt>
		<dd><code>Format</code> must be an atom and <code>Arguments</code> must be a list of format arguments (the token arguments are passed to a call to the <code>format/3</code> de facto standard predicate)</dd>
	<dt><code>term(Term, Options)</code></dt>
		<dd><code>Term</code> can be any term and <code>Options</code> must be a list of valid <code>write_term/3</code> output options (the token arguments are passed to a call to the <code>write_term/3</code> standard predicate)</dd>
	<dt><code>ansi(Attributes, Format, Arguments)</code></dt>
		<dd>Taken from SWI-Prolog; by default, do nothing; can be used for styled output</dd>
	<dt><code>begin(Kind, Var)</code></dt>
		<dd>Taken from SWI-Prolog; by default, do nothing; can be used together with <code>end(Var)</code> to wrap a message tokens</dd>
	<dt><code>end(Var)</code></dt>
		<dd>Taken from SWI-Prolog; by default, do nothing</dd>
</dl>
<p>
There are also predicates for printing a list of tokens, <a title="Consult reference manual" href="../refman/methods/print_message_tokens_3.html"><code>logtalk::print_message_tokens(Stream, Prefix, Tokens)</code></a>, for hooking into printing an individual token, <a title="Consult reference manual" href="../refman/methods/print_message_token_4.html"><code>logtalk::print_message_token(Stream, Prefix, Token, Tokens)</code></a>, and for setting default output stream and message prefixes, <a title="Consult reference manual" href="../refman/methods/message_prefix_stream_4.html"><code>logtalk::message_prefix_stream(Kind, Component, Prefix, Stream)</code></a>. For example, the SWI-Prolog adapter file uses the <code>print_message_token/4</code> hook predicate to enable coloring of messages printed on a console.
</p>
<p>
Using the message printing mechanism in your applications and libraries is easy. Simply chose a component name for your application, call <code>logtalk::print_message/3</code> for every message that you may want to print, and define default translations for your message terms using the multifile non-terminal <code>logtalk::message_tokens/2</code>. For a full programming example, see e.g. the <code>lgtunit</code> tool code.
</p>

<h3 id="predicates_questions">Asking questions</h3>

<p>
Logtalk features a <em>structured question asking</em> mechanism that complements the message printing mechanism. This feature provides an abstraction for the common task of asking a user a question and reading back its reply. By default, this mechanism writes the question and reads the answer from the current user input and output streams but allows both steps to be intercepted, filtered, rewritten, and redirected. A typical example is to use a GUI dialog for asking questions.
</p>
<p>
The question asking mechanism works in tandem with the message printing mechanism, using it to print the question text and a prompt. It provides a asking predicate and a hook predicate, both declared and defined in the <code>logtalk</code> built-in object. The asking predicate is <a title="Consult reference manual" href="../refman/methods/ask_question_5.html"><code>logtalk::ask_question(Kind, Component, Question, Check, Answer)</code></a>, which is used for ask a question and read the answer. The hook predicate is <a title="Consult reference manual" href="../refman/methods/question_hook_5.html"><code>logtalk::question_hook(Question, Kind, Component, Check, Answer)</code></a> takes the same arguments and is used for intercepting questions. The <code>Kind</code> argument is used to represent the nature of the question being asked. Its default value is <code>question</code> but it can be any atom or compound term, e.g. <code>question(parameters)</code>. Using a compound term allows easy partitioning of messages of the same kind in different groups. The <code>Check</code> argument is a closure that is converted into a checking goal taking as argument the user answer. The <code>ask_question/5</code> implements a read loop that terminates when this checking predicate is true. The question itself is a term that is translated into printing tokens using the <code>logtalk::message_tokens/2</code> multifile predicate.
</p>
<p>
There is also a user-defined multifile predicate for setting default prompt and input streams, <a title="Consult reference manual" href="../refman/methods/question_prompt_stream_4.html"><code>logtalk::question_prompt_stream(Kind, Component, Prompt, Stream)</code></a>.
</p>
<p>
An usage example of this mechanism is found on the <code>debugger</code> tool where it's used to abstract the user interaction when tracing a goal execution in debug mode.
</p>

<h2 id="predicates_properties">Predicate properties</h2>

<p>
We can find the properties of visible predicates by calling the <a title="Consult reference manual" href="../refman/methods/predicate_property_2.html"><code>predicate_property/2</code></a> built-in method. For example:
</p>
<pre>| ?- bar::predicate_property(foo(_), Property).</pre>
<p>
Note that this method respects the predicate's scope declarations. For instance, the above call will only return properties for public predicates.
</p>
<p>
An object's set of visible predicates is the union of all the predicates declared for the object with all the built-in methods and all the Logtalk and Prolog built-in predicates.
</p>
<p>
The following predicate properties are supported:
</p>
<dl>
	<dt><code>scope(Scope)</code></dt>
		<dd>The predicate scope (useful for finding the predicate scope with a single call to <code>predicate_property/2</code>)</dd>
	<dt><code>public</code>, <code>protected</code>, <code>private</code></dt>
		<dd>The predicate scope (useful for testing if a predicate have a specific scope)</dd>
	<dt><code>static</code>, <code>dynamic</code></dt>
		<dd>All predicates are either static or dynamic (note, however, that a dynamic predicate can only be abolished if it was dynamically declared)</dd>
	<dt><code>logtalk</code>, <code>prolog</code>, <code>foreign</code></dt>
		<dd>A predicate can be defined in Logtalk source code, Prolog code, or in foreign code (e.g. in C)</dd>
	<dt><code>built_in</code></dt>
		<dd>The predicate is a built-in predicate</dd>
	<dt><code>multifile</code></dt>
		<dd>The predicate is declared multifile (i.e. it can have clauses defined in several entities)</dd>
	<dt><code>meta_predicate(Template)</code></dt>
		<dd>The predicate is declared as a meta-predicate with the specified template</dd>
	<dt><code>coinductive(Template)</code></dt>
		<dd>The predicate is declared as a coinductive predicate with the specified template</dd>
	<dt><code>declared_in(Entity)</code></dt>
		<dd>The predicate is declared (using a scope directive) in the specified entity</dd>
	<dt><code>defined_in(Entity)</code></dt>
		<dd>The predicate definition is looked up in the specified entity (note that this property does not necessarily imply that clauses for the predicate exist in <code>Entity</code>; the predicate can simply be false as per the closed world assumption)</dd>
	<dt><code>redefined_from(Entity)</code></dt>
		<dd>The predicate is a redefinition of a predicate definition inherited from the specified entity</dd>
	<dt><code>non_terminal(NonTerminal//Arity)</code></dt>
		<dd>The predicate resulted from the compilation of the specified grammar rule non-terminal</dd>
	<dt><code>alias_of(Predicate)</code></dt>
		<dd>The predicate (name) is an alias for the specified predicate</dd>
	<dt><code>alias_declared_in(Entity)</code></dt>
		<dd>The predicate alias is declared in the specified entity</dd>
	<dt><code>synchronized</code></dt>
		<dd>The predicate is declared as synchronized (i.e. it's a deterministic predicate synchronized using a mutex when using a backend Prolog compiler supporting a compatible multi-threading implementation)</dd>
</dl>
<p>
Some properties are only available when the entities are defined in source files and when those source files are compiled with the <code>source_data</code> flag turned on:
</p>
<dl>
	<dt><code>auxiliary</code></dt>
		<dd>The predicate is not user-defined but rather automatically generated by the compiler or the term-expansion mechanism</dd>
	<dt><code>mode(Mode, Solutions)</code></dt>
		<dd>Instantiation, type, and determinism mode for the predicate (which can have multiple modes)</dd>
	<dt><code>info(ListOfPairs)</code></dt>
		<dd>Documentation key-value pairs as specified in the user-defined <code>info/2</code> directive</dd>
	<dt><code>number_of_clauses(N)</code></dt>
		<dd>The number of clauses for the predicate existing at compilation time (note that this property is not updated at runtime when asserting and retracting clauses for dynamic predicates)</dd>
	<dt><code>declared_in(Entity, Line)</code></dt>
		<dd>The predicate is declared (using a scope directive) in the specified entity in a source file at the specified line (if applicable)</dd>
	<dt><code>defined_in(Entity, Line)</code></dt>
		<dd>The predicate is defined in the specified entity in a source file at the specified line (if applicable)</dd>
	<dt><code>redefined_from(Entity, Line)</code></dt>
		<dd>The predicate is a redefinition of a predicate definition inherited from the specified entity, which is defined in a source file at the specified line (if applicable)</dd>
	<dt><code>alias_declared_in(Entity, Line)</code></dt>
		<dd>The predicate alias is declared in the specified entity in a source file at the specified line (if applicable)</dd>
</dl>
<p>
The properties <code>declared_in/1-2</code>, <code>defined_in/1-2</code>, and <code>redefined_from/1-2</code> do not apply to built-in methods and Logtalk or Prolog built-in predicates. Note that if a predicate is declared in a category imported by the object, it will be the category name &mdash; not the object name &mdash; that will be returned by the property <code>declared_in/1</code>. The same is true for protocol declared predicates.
</p>

<h2 id="predicates_finding">Finding declared predicates</h2>

<p>
We can find, by backtracking, all visible user predicates by calling the <a title="Consult reference manual" href="../refman/methods/current_predicate_1.html"><code>current_predicate/1</code></a> built-in method. This method respects the predicate's scope declarations. For instance, the following call:
</p>
<pre>| ?- some_object::current_predicate(Functor/Arity).</pre>
<p>
will only return user predicates that are declared public. The predicate property <code>non_terminal/1</code> may be used to retrieve all grammar rule non-terminals declared for an object. For example:
</p>
<pre>current_non_terminal(Object, NonTerminal//Args) :-
    Object::current_predicate(Functor/Arity),
    functor(Predicate, Functor, Arity),
    Object::predicate_property(Predicate, non_terminal(NonTerminal//Args)).</pre>
<p>
Usually, the non-terminal and the corresponding predicate share the same functor but users should not rely on this always being true.
</p>

<h2 id="predicates_prolog">Calling Prolog built-in predicates</h2>

<p>
In predicate definitions, predicate calls which are not prefixed with a message sending operator (either <code>::</code> or <code>^^</code>), are compiled to either calls to local predicates or as calls to Logtalk/Prolog built-in predicates. A predicate call is compiled as a call to a local predicate if the object (or category) contains a scope directive, a definition for the called predicate, or a dynamic declaration for it. When the object (or category) does not contain either a definition of the called predicate or a corresponding dynamic declaration, Logtalk tests if the call corresponds to a Logtalk or Prolog built-in predicate. Calling a predicate which is neither a local predicate nor a Logtalk/Prolog built-in predicate results in a compile time warning. This means that, in the following example:
</p>
<pre>foo :-
    ...,
    write(bar),
    ...</pre>
<p>
the call to the predicate <code>write/1</code> will be compiled as a call to the corresponding Prolog built-in predicate unless the object (or category) encapsulating the above definition also contains a predicate named <code>write/1</code> or a dynamic declaration for the predicate.
</p>
<p>
When calling non-standard Prolog built-in predicates or using non-standard Prolog arithmetic functions, you may run into portability problems while trying your applications with different back-end Prolog compilers (non-standard predicates and non-standard arithmetic functions are often specific to a Prolog compiler). You may use the Logtalk compiler flag <a title="Consult user manual" href="programming.html#programming_flags"><code>portability/1</code></a> to help check for problematic calls in your code.
</p>

<h3 id="predicates_prolog_meta">Calling Prolog non-standard meta-predicates</h3>

<p>
Prolog built-in meta-predicates may only be called locally within objects or categories, i.e. they cannot be used as messages. Compiling calls to non-standard, Prolog built-in meta-predicates can be tricky, however, as there is no standard way of checking if a built-in predicate is also a meta-predicate and finding out which are its meta-arguments. The solution is to explicitly declare them in the corresponding Prolog adapter file using the predicate <code>'$lgt_pl_meta-predicate'/3</code>. For example:
</p>
<pre>'$lgt_prolog_meta_predicate'(*-&gt;(_, _), (*-&gt;(0, 0), control_construct).
'$lgt_prolog_meta_predicate'(findall(_, _, _, _), findall(*, 0, *, *), predicate).</pre>

<h2 id="predicates_prolog_user">Calling Prolog user-defined predicates</h2>

<p>
Prolog user-defined predicates can be called from within objects or categories by either using the <a title="Consult reference manual" href="../control/external_call_1.html"><code>{}/1</code></a> compiler bypass control construct. For example:
</p>
<pre>foo :-
    ...,
    {bar},
    ...</pre>
<p>
In alternative, you can also use the <a title="Consult reference manual" href="../refman/directives/uses_2.html"><code>uses/2</code></a> directive and write:
</p>
<pre>
:- uses(user, [bar/0]).

foo :-
    ...,
    bar,
    ...</pre>
<p>
Note that <code>user</code> is a pseudo-object in Logtalk containing all predicate definitions that are not encapsulated (either in a Logtalk entity or a Prolog module).
</p>

<h3 id="predicates_prolog_module">Calling Prolog module predicates</h3>

<p>
To call Prolog module predicates from within objects or categories you can use simply write:
</p>
<pre>foo :-
    ...,
    module:bar,
    ...</pre>
<p>
You can also use in alternative the <a title="Consult reference manual" href="../refman/directives/use_module_2.html"><code>use_module/2</code></a> directive:
</p>
<pre>
:- use_module(module, [bar/0]).

foo :-
    ...,
    bar,
    ...</pre>
<p>
Note that the first argument of the <code>use_module/2</code>, when used within an object or a category, should be a module name, not a file name. The actual module code should be loaded prior to compilation of Logtalk that uses it. In particular, programmers should not expect that the module be auto-loaded (when using back-end Prolog compilers supporting an autoloading mechanism).
</p>
<p>
When the module predicate is a meta-predicate but for some reason you don't want its calls to be compiled as such, you can use the <a title="Consult reference manual" href="../control/external_call_1.html"><code>{}/1</code></a> compiler bypass control construct as before:
</p>
<pre>foo :-
    ...,
    {module:bar},
    ...</pre>
<p>
This workaround is sometimes necessary when calling module meta-predicates whose meta-predicate templates are ambiguous and cannot be processed by the Logtalk compiler (note, however, that it's often possible to specify an overriding meta-predicate directive within the object or category making the call).
</p>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>
		<span>Last updated on: May 26, 2015</span>
	</div>
	<div class="navbottom">
		<span><a href="categories.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="inheritance.html">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
