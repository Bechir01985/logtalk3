
.. index:: threaded_peek/1-2
.. _predicates_threaded_peek_1_2:

threaded_peek/1-2
=================

Description
-----------

::

   threaded_peek(Goal)
   threaded_peek(Goal, Tag)

Checks if the result of proving ``Goal`` in a new thread is already
available. This call succeeds or fails without blocking execution
waiting for a reply to be available.

The argument of this predicate should be a *variant* of the argument of
the corresponding :ref:`predicates_threaded_call_1_2` call.
When the predicate argument is subsumed by the ``threaded_call/1`` call
argument, the ``threaded_peek/1`` call will succeed iff its argument
unifies with an already available solution of the (more general) goal.

The variant ``threaded_peek/2`` accepts a threaded call identifier tag
generated by the calls to the :ref:`predicates_threaded_call_1_2` and
:ref:`predicates_threaded_once_1_2` predicates. Tags shall
be regarded as an opaque term; users shall not rely on its type.

Template and modes
------------------

::

   threaded_peek(+callable)
   threaded_peek(+callable, +nonvar)

Errors
------

Goal is a variable:
   ``instantiation_error``
Goal is neither a variable nor a callable term:
   ``type_error(callable, Goal)``
Tag is a variable:
   ``instantiation_error``

Examples
--------

To check for an asynchronous goal proof result:
   ``threaded_peek(Goal)``
To check for an asynchronous message to *self* result:
   ``threaded_peek(::Goal)``
To check for an asynchronous message result:
   ``threaded_peek(Object::Goal)``

.. seealso::

   :ref:`predicates_threaded_call_1_2`,
   :ref:`predicates_threaded_exit_1_2`,
   :ref:`predicates_threaded_ignore_1`,
   :ref:`predicates_threaded_once_1_2`,
   :ref:`predicates_threaded_1`
