<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<!--
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  
%  This file is part of Logtalk <http://logtalk.org/>    
%  Copyright (c) 1998-2015 Paulo Moura <pmoura@logtalk.org>
%  
%  Logtalk is free software. You can redistribute it and/or modify it under
%  the terms of the FSF GNU General Public License 3  (plus some additional
%  terms per section 7).        Consult the `LICENSE.txt` file for details.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk entity directive: use_module/2</title>
	<link rel="stylesheet" href="../../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk reference manual</div>
<div class="top-right">Entity directive: use_module/2</div>
<div class="bottom-left"><span class="page"/></div>
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../../index.html">Contents</a> &gt; <a href="../index.html">Reference Manual</a> &gt; <a href="../index.html#directives">Directives</a> &gt; use_module/2</div>

<h2 id="directives_use_module_2" class="codenp">use_module/2</h2>

<h4>Description</h4>

<pre>use_module(Module, Predicates)</pre>
<p>
This directive is supported only when using a back-end Prolog compiler that supports modules. It declares that all calls (made from predicates defined in the category or object containing the directive) to the specified predicates are to be interpreted as calls to explicitly-qualified module predicates. Thus, this directive may be used to simplify writing of predicate definitions by allowing the programmer to omit the <code>Module:</code> prefix when using the predicates listed in the directive (as long as the predicate calls do not occur as arguments for non-standard Prolog meta-predicates not declared on the adapter files). It is also possible to include operator declarations, <code>op(Precedence, Associativity, Operator)</code>, in the second argument.
</p>
<p>
This directive is also used when compiling calls to the database and reflection built-in methods by examining these methods predicate arguments.
</p>
<p>
It is possible to specify a predicate alias using the notation <code>Functor/Arity as Alias/Arity</code> or, in alternative, the notation <code>Functor/Arity:Alias/Arity</code>. Aliases may be used either for avoiding conflicts between predicates specified in <code>use_module/2</code> and <code>uses/2</code> directives or for giving more meaningful names considering the using context of the predicates.
</p>
<p>
Note that this directive differs from the directive with the same name found on some Prolog implementations by requiring the first argument to be a module name (an atom) instead of a file specification. In Logtalk, there's no mixing between <em>loading</em> a resource and (declaring the) <em>using</em> (of) a resource. As a consequence, this directive doesn't automatically load the module. Loading the module file is dependent of the used backend Prolog compiler and must be done separately (usually, using a source file <code>use_module/1</code> or <code>use_module/2</code> directive in the entity file or in the application loader file). Also note that the name of the module may differ from the name of the module file.
</p>
<p>
The modules should be loaded prior to the compilation of entities that call the module predicates. This is required in general to allow the compiler to check if the called module predicate is a meta-predicate and retrieve its meta-predicate template to ensure proper call compilation.
</p>

<h4>Template and modes</h4>

<pre>use_module(+module_identifier, +predicate_indicator_list)</pre>

<h4>Examples</h4>

<pre>:- use_module(lists, [append/3, member/2]).
:- use_module(store, [data/2]).

foo :-
    ...,
    findall(X, member(X, L), A),    % the same as findall(X, lists:member(X, L), A)
    append(A, B, C),                % the same as lists:append(A, B, C)
    assertz(data(X, C)),            % the same as assertz(store:data(X, C))
    ...</pre>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>
		<span>Last updated on: October 14, 2015</span>
	</div>
	<div class="navbottom">
		<span><a href="../index.html#directives">previous</a> | <a href="../../glossary.html">glossary</a> | <a href="../index.html#directives">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
