
.. index:: threaded_exit/1-2
.. _predicates_threaded_exit_1_2:

threaded_exit/1-2
=================

Description
-----------

::

   threaded_exit(Goal)
   threaded_exit(Goal, Tag)

Retrieves the result of proving ``Goal`` in a new thread. This predicate
blocks execution until the reply is sent to the
:term:`this` message queue by the thread
executing the goal. When there is no thread proving the goal, the
predicate generates an exception. This predicate is non-deterministic,
providing access to any alternative solutions of its argument.

The argument of this predicate should be a *variant* of the argument of
the corresponding :ref:`predicates_threaded_call_1_2` call.
When the predicate argument is subsumed by the ``threaded_call/1`` call
argument, the ``threaded_exit/1`` call will succeed iff its argument is
a solution of the (more general) goal.

The variant ``threaded_exit/2`` accepts a threaded call identifier tag
generated by the calls to the :ref:`predicates_threaded_call_1_2` and
:ref:`predicates_threaded_once_1_2` predicates. Tags shall
be regarded as an opaque term; users shall not rely on its type.

Template and modes
------------------

::

   threaded_exit(+callable)
   threaded_exit(+callable, +nonvar)

Errors
------

Goal is a variable:
   ``instantiation_error``
Goal is neither a variable nor a callable term:
   ``type_error(callable, Goal)``
no thread is running for proving Goal:
   ``existence_error(goal_thread, Goal)``
Tag is a variable:
   ``instantiation_error``

Examples
--------

To retrieve an asynchronous goal proof result:
   ``threaded_exit(Goal)``
To retrieve an asynchronous message to *self* result:
   ``threaded_exit(::Goal)``
To retrieve an asynchronous message result:
   ``threaded_exit(Object::Goal)``

See also
--------

:ref:`predicates_threaded_call_1_2`,
:ref:`predicates_threaded_ignore_1`,
:ref:`predicates_threaded_once_1_2`,
:ref:`predicates_threaded_peek_1_2`
:ref:`predicates_threaded_1`
